<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Parsing JSON the hard way</title>
  <meta name="description" content="This article was written by Aaron Patterson, a Rubydeveloper living in Seattle, WA.  He’s been having fun writing Ruby for the past7 years, and hopes to shar...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://practicingruby.com/articles/parsing-json-the-hard-way">
  <link rel="alternate" type="application/rss+xml" title="Practicing Ruby" href="http://practicingruby.com/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33127211-2', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Practicing Ruby</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="/about">About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Parsing JSON the hard way</h1>
    <p class="post-meta"><time datetime="2013-01-01T00:00:00-05:00" itemprop="datePublished">Jan 1, 2013</time> • Aaron Patterson</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>This article was written by Aaron Patterson, a Ruby
developer living in Seattle, WA.  He’s been having fun writing Ruby for the past
7 years, and hopes to share his love of Ruby with you.</em></p>

<p>Hey everybody!  I hope you’re having a great day today!  The sun has peeked out
of the clouds for a bit today, so I’m doing great!</p>

<p>In this article, we’re going to be looking at some compiler tools for use with Ruby.  In
order to explore these tools, we’ll write a JSON parser.  I know you’re saying,
“but Aaron, <em>why</em> write a JSON parser?  Don’t we have like 1,234,567 of them?”.
Yes!  We do have precisely 1,234,567 JSON parsers available in Ruby!  We’re
going to parse JSON because the grammar is simple enough that we can finish the
parser in one sitting, and because the grammar is complex enough that we can
exercise some of Ruby’s compiler tools.</p>

<p>As you read on, keep in mind that this isn’t an article about parsing JSON, 
its an article about using parser and compiler tools in Ruby.</p>

<h2 id="the-tools-well-be-using">The Tools We’ll Be Using</h2>

<p>I’m going to be testing this with Ruby 2.1.0, but it should work under any
flavor of Ruby you wish to try.  Mainly, we will be using a tool called <code class="highlighter-rouge">Racc</code>,
and a tool called <code class="highlighter-rouge">StringScanner</code>.</p>

<p><strong>Racc</strong></p>

<p>We’ll be using Racc to generate our parser.  Racc is an LALR parser generator
similar to YACC.  YACC stands for “Yet Another Compiler Compiler”, but this is
the Ruby version, hence “Racc”.  Racc converts a grammar file (the “.y” file)
to a Ruby file that contains state transitions.  These state transitions are
interpreted by the Racc state machine (or runtime).  The Racc runtime ships
with Ruby, but the tool that converts the “.y” files to state tables does not.
In order to install the converter, do <code class="highlighter-rouge">gem install racc</code>.</p>

<p>We will write “.y” files, but users cannot run the “.y” files.  First we convert
them to runnable Ruby code, and ship the runnable Ruby code in our gem.  In
practical terms, this means that <em>only we install the Racc gem</em>, other users
do not need it.</p>

<p>Don’t worry if this doesn’t make sense right now.  It will become more clear
when we get our hands dirty and start playing with code.</p>

<p><strong>StringScanner</strong></p>

<p>Just like the name implies, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html">StringScanner</a>
is a class that helps us scan strings.  It keeps track of where we are
in the string, and lets us advance forward via regular expressions or by
character.</p>

<p>Let’s try it out!  First we’ll create a <code class="highlighter-rouge">StringScanner</code> object, then we’ll scan
some letters from it:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'strscan'</span>

<span class="n">ss</span> <span class="o">=</span> <span class="no">StringScanner</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'aabbbbb'</span> <span class="c1">#=&gt; #&lt;StringScanner 0/7 @ "aabbb..."&gt;</span>
<span class="n">ss</span><span class="p">.</span><span class="nf">scan</span> <span class="sr">/a/</span> <span class="c1">#=&gt; "a"</span>
<span class="n">ss</span><span class="p">.</span><span class="nf">scan</span> <span class="sr">/a/</span> <span class="c1">#=&gt; "a"</span>
<span class="n">ss</span><span class="p">.</span><span class="nf">scan</span> <span class="sr">/a/</span> <span class="c1">#=&gt; nil</span>
<span class="n">ss</span> <span class="c1">#=&gt; #&lt;StringScanner 2/7 "aa" @ "bbbbb"&gt;</span>
</code></pre>
</div>

<p>Notice that the third call to
<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html#method-i-scan">StringScanner#scan</a>
resulted in a <code class="highlighter-rouge">nil</code>, since the regular expression did not match from the current
position.  Also note that when you inspect the <code class="highlighter-rouge">StringScanner</code> instance, you can
see the position of the scanner (in this case <code class="highlighter-rouge">2/7</code>).</p>

<p>We can also move through the scanner character by character using
<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html#method-i-getch">StringScanner#getch</a>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">ss</span> <span class="c1">#=&gt; #&lt;StringScanner 2/7 "aa" @ "bbbbb"&gt;</span>
<span class="n">ss</span><span class="p">.</span><span class="nf">getch</span> <span class="c1">#=&gt; "b"</span>

<span class="n">ss</span> <span class="c1">#=&gt; #&lt;StringScanner 3/7 "aab" @ "bbbb"&gt;</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">getch</code> method returns the next character, and advances the pointer by one.</p>

<p>Now that we’ve covered the basics for scanning strings, let’s take a 
look at using Racc.</p>

<h2 id="racc-basics">Racc Basics</h2>

<p>As I said earlier, Racc is an LALR parser generator.  You can think of it as a
system that lets you write limited regular expressions that can execute
arbitrary code at different points as they’re being evaluated.</p>

<p>Let’s look at an example.  Suppose we have a pattern we want to match:
<code class="highlighter-rouge">(a|c)*abb</code>.  That is, we want to match any number of ‘a’ or ‘c’ followed by
‘abb’.  To translate this to a Racc grammar, we try to break up this regular
expression to smaller parts, and assemble them as the whole.  Each part is
called a “production”.  Let’s try breaking up this regular expression so that we
can see what the productions look like, and the format of a Racc grammar file.</p>

<p>First we create our grammar file.  At the top of the file, we declare the Ruby
class to be produced, followed by the <code class="highlighter-rouge">rule</code> keyword to indicate that we’re
going to declare the productions, followed by the <code class="highlighter-rouge">end</code> keyword to indicate the
end of the productions:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
end
</code></pre>
</div>

<table>
  <tbody>
    <tr>
      <td>Next lets add the production for “a</td>
      <td>c”.  We’ll call this production <code class="highlighter-rouge">a_or_c</code>:</td>
    </tr>
  </tbody>
</table>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
  a_or_c : 'a' | 'c' ;
end
</code></pre>
</div>

<p>Now we have a rule named <code class="highlighter-rouge">a_or_c</code>, and it matches the characters ‘a’ or ‘c’.  In
order to match one or more <code class="highlighter-rouge">a_or_c</code> productions, we’ll add a recursive
production called <code class="highlighter-rouge">a_or_cs</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
  a_or_cs
    : a_or_cs a_or_c
    | a_or_c
    ;
  a_or_c : 'a' | 'c' ;
end
</code></pre>
</div>

<p>The <code class="highlighter-rouge">a_or_cs</code> production recurses on itself, equivalent to the regular
expression <code class="highlighter-rouge">(a|c)+</code>.  Next, a production for ‘abb’:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
  a_or_cs
    : a_or_cs a_or_c
    | a_or_c
    ;
  a_or_c : 'a' | 'c' ;
  abb    : 'a' 'b' 'b' 
end
</code></pre>
</div>

<p>Finally, the <code class="highlighter-rouge">string</code> production ties everything together:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
  string
    : a_or_cs abb
    | abb
    ;
  a_or_cs
    : a_or_cs a_or_c
    | a_or_c
    ;
  a_or_c : 'a' | 'c' ;
  abb    : 'a' 'b' 'b';
end
</code></pre>
</div>

<p>This final production matches one or more ‘a’ or ‘c’ characters followed by
‘abb’, or just the string ‘abb’ on its own.  This is equivalent to our original
regular expression of <code class="highlighter-rouge">(a|c)*abb</code>.</p>

<p><strong>But Aaron, this is so long!</strong></p>

<p>I know, it’s much longer than the regular expression version.  However, we can
add arbitrary Ruby code to be executed at any point in the matching process.
For example, every time we find just the string “abb”, we can execute some
arbitrary code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Parser
rule
  string
    | a_or_cs abb
    | abb         
    ;
  a_or_cs
    : a_or_cs a_or_c
    | a_or_c
    ;
  a_or_c : 'a' | 'c' ;
  abb    : 'a' 'b' 'b' { puts "I found abb!" };
end
</code></pre>
</div>

<p>The Ruby code we want to execute should be wrapped in curly braces and placed
after the rule where we want the trigger to fire.</p>

<p>To use this parser, we also need a tokenizer that can break the input
data into tokens, along with some other boilerplate code. If you are curious
about how that works, you can check out <a href="https://gist.githubusercontent.com/sandal/9532497/raw/8e3bb03fc24c8f6604f96516bf242e7e13d0f4eb/parser_example.y">this standalone
example</a>.</p>

<p>Now that we’ve covered the basics, we can use knowledge we have so far to build 
an event based JSON parser and tokenizer.</p>

<h2 id="building-our-json-parser">Building our JSON Parser</h2>

<p>Our JSON parser is going to consist of three different objects, a parser, a
tokenizer, and document handler.The parser will be written with a Racc grammar, 
and will ask the tokenizer for input from the input stream.  Whenever the parser 
can identify a part of the JSON stream, it will send an event to the document 
handler.  The document handler is responsible for collecting the JSON 
information and translating it to a Ruby data structure. When we read in 
a JSON document, the following method calls are made:</p>

<p><img src="//i.imgur.com/HZ0Sa.png" alt="method calls" /></p>

<p>It’s time to get started building this system. We’ll focus on building the 
tokenizer first, then work on the grammar for the parser, and finally implement 
the document handler.</p>

<h2 id="building-the-tokenizer">Building the tokenizer</h2>

<p>Our tokenizer is going to be constructed with an IO object.  We’ll read the
JSON data from the IO object.  Every time <code class="highlighter-rouge">next_token</code> is called, the tokenizer
will read a token from the input and return it. Our tokenizer will return the 
following tokens, which we derived from the <a href="http://www.json.org/">JSON spec</a>:</p>

<ul>
  <li>Strings</li>
  <li>Numbers</li>
  <li>True</li>
  <li>False</li>
  <li>Null</li>
</ul>

<p>Complex types like arrays and objects will be determined by the parser.</p>

<p><strong><code class="highlighter-rouge">next_token</code> return values:</strong></p>

<p>When the parser calls <code class="highlighter-rouge">next_token</code> on the tokenizer, it expects a two element
array or a <code class="highlighter-rouge">nil</code> to be returned.  The first element of the array must contain
the name of the token, and the second element can be anything (but most people
just add the matched text).  When a <code class="highlighter-rouge">nil</code> is returned, that indicates there are
no more tokens left in the tokenizer.</p>

<p><strong><code class="highlighter-rouge">Tokenizer</code> class definition:</strong></p>

<p>Let’s look at the source for the Tokenizer class and walk through it:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RJSON</span>
  <span class="k">class</span> <span class="nc">Tokenizer</span>
    <span class="nc">STRING</span> <span class="o">=</span> <span class="sr">/"(?:[^"\\]|\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4}))*"/</span>
    <span class="no">NUMBER</span> <span class="o">=</span> <span class="sr">/-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/</span>
    <span class="no">TRUE</span>   <span class="o">=</span> <span class="sr">/true/</span>
    <span class="no">FALSE</span>  <span class="o">=</span> <span class="sr">/false/</span>
    <span class="no">NULL</span>   <span class="o">=</span> <span class="sr">/null/</span>

    <span class="k">def</span> <span class="nf">initialize</span> <span class="n">io</span>
      <span class="vi">@ss</span> <span class="o">=</span> <span class="no">StringScanner</span><span class="p">.</span><span class="nf">new</span> <span class="n">io</span><span class="p">.</span><span class="nf">read</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">next_token</span>
      <span class="k">return</span> <span class="k">if</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">eos?</span>

      <span class="k">case</span>
      <span class="k">when</span> <span class="n">text</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="no">STRING</span><span class="p">)</span> <span class="k">then</span> <span class="p">[</span><span class="ss">:STRING</span><span class="p">,</span> <span class="n">text</span><span class="p">]</span>
      <span class="k">when</span> <span class="n">text</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="no">NUMBER</span><span class="p">)</span> <span class="k">then</span> <span class="p">[</span><span class="ss">:NUMBER</span><span class="p">,</span> <span class="n">text</span><span class="p">]</span>
      <span class="k">when</span> <span class="n">text</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="no">TRUE</span><span class="p">)</span>   <span class="k">then</span> <span class="p">[</span><span class="ss">:TRUE</span><span class="p">,</span> <span class="n">text</span><span class="p">]</span>
      <span class="k">when</span> <span class="n">text</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="no">FALSE</span><span class="p">)</span>  <span class="k">then</span> <span class="p">[</span><span class="ss">:FALSE</span><span class="p">,</span> <span class="n">text</span><span class="p">]</span>
      <span class="k">when</span> <span class="n">text</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="no">NULL</span><span class="p">)</span>   <span class="k">then</span> <span class="p">[</span><span class="ss">:NULL</span><span class="p">,</span> <span class="n">text</span><span class="p">]</span>
      <span class="k">else</span>
        <span class="n">x</span> <span class="o">=</span> <span class="vi">@ss</span><span class="p">.</span><span class="nf">getch</span>
        <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>First we declare some regular expressions that we’ll use along with the string
scanner.  These regular expressions were derived from the definitions on
<a href="http://www.json.org">json.org</a>.  We instantiate a string scanner object in the
constructor.  String scanner requires a string on construction, so we read the
IO object.  However, we could build an alternative tokenizer that reads from the
IO as needed.</p>

<p>The real work is done in the <code class="highlighter-rouge">next_token</code> method.  The <code class="highlighter-rouge">next_token</code> method
returns nil if there is nothing left to read from the string scanner, then it
tries each regular expression until it finds a match.  If it finds a match, it
returns the name of the token (for example <code class="highlighter-rouge">:STRING</code>) along with the text that
it matched.  If none of the regular expressions match, then we read one
character off the scanner, and return that character as both the name of the
token, and the value.</p>

<p>Let’s try feeding the tokenizer a JSON string and see what tokens come out:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">tok</span> <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Tokenizer</span><span class="p">.</span><span class="nf">new</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'{"foo":null}'</span>
<span class="c1">#=&gt; #&lt;RJSON::Tokenizer:0x007fa8529fbeb8 @ss=#&lt;StringScanner 0/12 @ "{\"foo..."&gt;&gt;</span>

<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; ["{", "{"]</span>
<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; [:STRING, "\"foo\""]</span>
<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; [":", ":"]</span>
<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; [:NULL, "null"]</span>
<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; ["}", "}"]</span>
<span class="n">tok</span><span class="p">.</span><span class="nf">next_token</span> <span class="c1">#=&gt; nil</span>
</code></pre>
</div>

<p>In this example, we wrap the JSON string with a <code class="highlighter-rouge">StringIO</code> object in order to
make the string quack like an IO.  Next, we try reading tokens from the
tokenizer.  Each token the Tokenizer understands has the name as the first value of
the array, where the unknown tokens have the single character value.  For
example, string tokens look like this: <code class="highlighter-rouge">[:STRING, "foo"]</code>, and unknown tokens
look like this: <code class="highlighter-rouge">['(', '(']</code>.   Finally, <code class="highlighter-rouge">nil</code> is returned when the input has
been exhausted.</p>

<p>This is it for our tokenizer.  The tokenizer is initialized with an <code class="highlighter-rouge">IO</code> object, 
and has only one method: <code class="highlighter-rouge">next_token</code>.  Now we can focus on the parser side.</p>

<h2 id="building-the-parser">Building the parser</h2>

<p>We have our tokenizer in place, so now it’s time to assemble the parser.  First
we need to do a little house keeping.  We’re going to generate a Ruby file from
our <code class="highlighter-rouge">.y</code> file.  The Ruby file needs to be regenerated every time the <code class="highlighter-rouge">.y</code> file
changes.  A Rake task sounds like the perfect solution.</p>

<p><strong>Defining a compile task:</strong></p>

<p>The first thing we’ll add to the Rakefile is a rule that says <em>“translate .y files to
.rb files using the following command”</em>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">rule</span> <span class="s1">'.rb'</span> <span class="o">=&gt;</span> <span class="s1">'.y'</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="n">sh</span> <span class="s2">"racc -l -o </span><span class="si">#{</span><span class="n">t</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">t</span><span class="p">.</span><span class="nf">source</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Then we’ll add a “compile” task that depends on the generated <code class="highlighter-rouge">parser.rb</code> file:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">task</span> <span class="ss">:compile</span> <span class="o">=&gt;</span> <span class="s1">'lib/rjson/parser.rb'</span>
</code></pre>
</div>

<p>We keep our grammar file as <code class="highlighter-rouge">lib/rjson/parser.y</code>, and when we run <code class="highlighter-rouge">rake
compile</code>, rake will automatically translate the <code class="highlighter-rouge">.y</code> file to a <code class="highlighter-rouge">.rb</code> file using
Racc.</p>

<p>Finally we make the test task depend on the compile task so that when we run
<code class="highlighter-rouge">rake test</code>, the compiled file is automatically generated:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">task</span> <span class="ss">:test</span> <span class="o">=&gt;</span> <span class="ss">:compile</span>
</code></pre>
</div>

<p>Now we can compile and test the <code class="highlighter-rouge">.y</code> file.</p>

<p><strong>Translating the JSON.org spec:</strong></p>

<p>We’re going to translate the diagrams from <a href="http://www.json.org/">json.org</a> to a
Racc grammar.  A JSON document should be an object or an array at the root, so
we’ll make a production called <code class="highlighter-rouge">document</code> and it should be an <code class="highlighter-rouge">object</code> or an
<code class="highlighter-rouge">array</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rule
  document
    : object
    | array
    ;
</code></pre>
</div>

<p>Next we need to define <code class="highlighter-rouge">array</code>.  The <code class="highlighter-rouge">array</code> production can either be empty, or
contain 1 or more values:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  array
    : '[' ']'
    | '[' values ']'
    ;
</code></pre>
</div>

<p>The <code class="highlighter-rouge">values</code> production can be recursively defined as one value, or many values
separated by a comma:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  values
    : values ',' value
    | value
    ;
</code></pre>
</div>

<p>The JSON spec defines a <code class="highlighter-rouge">value</code> as a string, number, object, array, true, false,
or null.  We’ll define it the same way, but for the immediate values such as
NUMBER, TRUE, and FALSE, we’ll use the token names we defined in the tokenizer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  value
    : string
    | NUMBER
    | object
    | array
    | TRUE
    | FALSE
    | NULL
    ;
</code></pre>
</div>

<p>Now we need to define the <code class="highlighter-rouge">object</code> production.  Objects can be empty, or
have many pairs:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  object
    : '{' '}'
    | '{' pairs '}'
    ;
</code></pre>
</div>

<p>We can have one or more pairs, and they must be separated with a comma.  We can
define this recursively like we did with the array values:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  pairs
    : pairs ',' pair
    | pair
    ;
</code></pre>
</div>

<p>Finally, a pair is a string and value separated by a colon:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  pair
    : string ':' value
    ;
</code></pre>
</div>

<p>Now we let Racc know about our special tokens by declaring them at the top, and
we have our full parser:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class RJSON::Parser
token STRING NUMBER TRUE FALSE NULL
rule
  document
    : object
    | array
    ;
  object
    : '{' '}'
    | '{' pairs '}'
    ;
  pairs
    : pairs ',' pair
    | pair
    ;
  pair : string ':' value ;
  array
    : '[' ']'
    | '[' values ']'
    ;
  values
    : values ',' value
    | value
    ;
  value
    : string
    | NUMBER
    | object
    | array
    | TRUE
    | FALSE
    | NULL
    ;
  string : STRING ;
end
</code></pre>
</div>

<h2 id="building-the-handler">Building the handler</h2>

<p>Our parser will send events to a document handler.  The document handler will
assemble the beautiful JSON bits in to lovely Ruby object!  Granularity of the
events is really up to you, but I’m going to go with 5 events:</p>

<ul>
  <li><code class="highlighter-rouge">start_object</code> - called when an object is started</li>
  <li><code class="highlighter-rouge">end_object</code>   - called when an object ends</li>
  <li><code class="highlighter-rouge">start_array</code>  - called when an array is started</li>
  <li><code class="highlighter-rouge">end_array</code>    - called when an array ends</li>
  <li><code class="highlighter-rouge">scalar</code>       - called with terminal values like strings, true, false, etc</li>
</ul>

<p>With these 5 events, we can assemble a Ruby object that represents the JSON
object we are parsing.</p>

<p><strong>Keeping track of events</strong></p>

<p>The handler we build will simply keep track of events sent to us by the parser.
This creates tree-like data structure that we’ll use to convert JSON to Ruby.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RJSON</span>
  <span class="k">class</span> <span class="nc">Handler</span>
    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@stack</span> <span class="o">=</span> <span class="p">[[</span><span class="ss">:root</span><span class="p">]]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">start_object</span>
      <span class="n">push</span> <span class="p">[</span><span class="ss">:hash</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">start_array</span>
      <span class="n">push</span> <span class="p">[</span><span class="ss">:array</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">end_array</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
    <span class="k">end</span>
    <span class="k">alias</span> <span class="ss">:end_object</span> <span class="ss">:end_array</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;&lt;</span> <span class="n">o</span>
      <span class="vi">@stack</span> <span class="o">&lt;&lt;</span> <span class="n">o</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>When the parser encounters the start of an object, the handler pushes a list on
the stack with the “hash” symbol to indicate the start of a hash.  Events that
are children will be added to the parent, then when the object end is
encountered the parent is popped off the stack.</p>

<p>This may be a little hard to understand, so let’s look at some examples.  If we
parse this JSON: <code class="highlighter-rouge"><span class="p">{</span><span class="nt">"foo"</span><span class="p">:{</span><span class="nt">"bar"</span><span class="p">:</span><span class="kc">null</span><span class="p">}}</span></code>, then the <code class="highlighter-rouge">@stack</code> variable will look
like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">[[</span><span class="ss">:root</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:hash</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:hash</span><span class="p">,</span>
      <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">],</span>
      <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="kp">nil</span><span class="p">]]]]]</span>
</code></pre>
</div>

<p>If we parse a JSON array, like this JSON: <code class="highlighter-rouge">["foo",null,true]</code>, the <code class="highlighter-rouge">@stack</code>
variable will look like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">[[</span><span class="ss">:root</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:array</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:scalar</span><span class="p">,</span> <span class="kp">true</span><span class="p">]]]]</span>
</code></pre>
</div>

<p><strong>Converting to Ruby:</strong></p>

<p>Now that we have an intermediate representation of the JSON, let’s convert it to
a Ruby data structure.  To convert to a Ruby data structure, we can just write a
recursive function to process the tree:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">result</span>
  <span class="n">root</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">last</span>
  <span class="n">process</span> <span class="n">root</span><span class="p">.</span><span class="nf">first</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="nf">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

<span class="kp">private</span>
<span class="k">def</span> <span class="nf">process</span> <span class="n">type</span><span class="p">,</span> <span class="n">rest</span>
  <span class="k">case</span> <span class="n">type</span>
  <span class="k">when</span> <span class="ss">:array</span>
    <span class="n">rest</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">first</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="nf">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
  <span class="k">when</span> <span class="ss">:hash</span>
    <span class="no">Hash</span><span class="p">[</span><span class="n">rest</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
      <span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">first</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="nf">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">}.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">to_a</span><span class="p">]</span>
  <span class="k">when</span> <span class="ss">:scalar</span>
    <span class="n">rest</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">result</code> method removes the <code class="highlighter-rouge">root</code> node and sends the rest to the <code class="highlighter-rouge">process</code>
method.  When the <code class="highlighter-rouge">process</code> method encounters a <code class="highlighter-rouge">hash</code> symbol it builds a hash
using the children by recursively calling <code class="highlighter-rouge">process</code>.  Similarly, when an
<code class="highlighter-rouge">array</code> symbol is found, an array is constructed recursively with the children.
Scalar values are simply returned (which prevents an infinite loop).  Now if we
call <code class="highlighter-rouge">result</code> on our handler, we can get the Ruby object back.</p>

<p>Let’s see it in action:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rjson'</span>

<span class="n">input</span>   <span class="o">=</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'{"foo":"bar"}'</span>
<span class="n">tok</span>     <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Tokenizer</span><span class="p">.</span><span class="nf">new</span> <span class="n">input</span>
<span class="n">parser</span>  <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">new</span> <span class="n">tok</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse</span>
<span class="n">handler</span><span class="p">.</span><span class="nf">result</span> <span class="c1"># =&gt; {"foo"=&gt;"bar"}</span>
</code></pre>
</div>

<p><strong>Cleaning up the RJSON API:</strong></p>

<p>We have a fully function JSON parser.  Unfortunately, the API is not very
friendly.  Let’s take the previous example, and package it up in a method:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RJSON</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
    <span class="n">input</span>   <span class="o">=</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span> <span class="n">json</span>
    <span class="n">tok</span>     <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Tokenizer</span><span class="p">.</span><span class="nf">new</span> <span class="n">input</span>
    <span class="n">parser</span>  <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">new</span> <span class="n">tok</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse</span>
    <span class="n">handler</span><span class="p">.</span><span class="nf">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Since we built our JSON parser to deal with IO from the start, we can add
another method for people who would like to pass a socket or file handle:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RJSON</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">load_io</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">tok</span>     <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Tokenizer</span><span class="p">.</span><span class="nf">new</span> <span class="n">input</span>
    <span class="n">parser</span>  <span class="o">=</span> <span class="no">RJSON</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">new</span> <span class="n">tok</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse</span>
    <span class="n">handler</span><span class="p">.</span><span class="nf">result</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
    <span class="n">load_io</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span> <span class="n">json</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now the interface is a bit more friendly:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rjson'</span>
<span class="nb">require</span> <span class="s1">'open-uri'</span>

<span class="no">RJSON</span><span class="p">.</span><span class="nf">load</span> <span class="s1">'{"foo":"bar"}'</span> <span class="c1"># =&gt; {"foo"=&gt;"bar"}</span>
<span class="no">RJSON</span><span class="p">.</span><span class="nf">load_io</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'http://example.org/some_endpoint.json'</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="reflections">Reflections</h2>

<p>So we’ve finished our JSON parser.  Along the way we’ve studied compiler
technology including the basics of parsers, tokenizers, and even interpreters
(yes, we actually interpreted our JSON!).  You should be proud of yourself!</p>

<p>The JSON parser we’ve built is versatile. We can:</p>

<ul>
  <li>Use it in an event driven manner by implementing a Handler object</li>
  <li>Use a simpler API and just feed strings</li>
  <li>Stream in JSON via IO objects</li>
</ul>

<p>I hope this article has given you the confidence to start playing with parser
and compiler technology in Ruby. Please leave a comment if you have any
questions for me.</p>

<h2 id="post-script">Post Script</h2>

<p>I want to follow up with a few bits of minutiae that I omitted to maintain
clarity in the article:</p>

<ul>
  <li>
    <p><a href="https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y">Here</a> is
the final grammar file for our JSON parser.  Notice 
the <a href="https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y#L53">—- inner section in the .y file</a>.
Anything in that section is included <em>inside</em> the generated parser class.  This
is how we get the handler object to be passed to the parser.</p>
  </li>
  <li>
    <p>Our parser actually <a href="https://github.com/tenderlove/rjson/blob/master/lib/rjson/parser.y#L42-50">does the
translation</a>
of JSON terminal nodes to Ruby.  So we’re actually doing the translation of JSON
to Ruby in two places: the parser <em>and</em> the document handler.  The document
handler deals with structure where the parser deals with immediate values (like
true, false, etc).  An argument could be made that none or all of this
translation <em>should</em> be done in the parser.</p>
  </li>
  <li>
    <p>Finally, I mentioned that <a href="https://github.com/tenderlove/rjson/blob/master/lib/rjson/tokenizer.rb">the
tokenizer</a>
buffers.  I implemented a simple non-buffering tokenizer that you can read
<a href="https://github.com/tenderlove/rjson/blob/master/lib/rjson/stream_tokenizer.rb">here</a>.
It’s pretty messy, but I think could be cleaned up by using a state machine.</p>
  </li>
</ul>

<p>That’s all. Thanks for reading! &lt;3 &lt;3 &lt;3</p>

<blockquote>
  <p>NOTE: If you’d like to learn more about this topic, consider doing the Practicing Ruby self-guided course on <a href="https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb">Streams, Files, and Sockets</a>. You’ve already completed one of its reading exercises by working through this article!</p>
</blockquote>

  </div>

  <div style="text-align: center">
    <h3><a href="/">Want to keep reading? Check out the archives for more.</a></h3>

    <small>Practicing Ruby is proudly independent, open source, and advertising free.<br/>If you insist on being asked for something in return, check out <a href="/support">how to support my work</a>.</small>
  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Send questions and feedback to:</li>
          <li><a href="mailto:gregory@practicingdeveloper.com">gregory@practicingdeveloper.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/practicingdeveloper"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">practicingdeveloper</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/practicingdev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">practicingdev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The world's largest collection of lessons for experienced Ruby developers.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
