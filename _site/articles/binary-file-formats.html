<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Working with binary file formats</title>
  <meta name="description" content="Even if we rarely give them much thought, binary file formats are everywhere.Ranging from images to audio files to nearly every other sort of media you canim...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/articles/binary-file-formats">
  <link rel="alternate" type="application/rss+xml" title="Practicing Ruby" href="http://yourdomain.com/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33127211-2', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Practicing Ruby</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Working with binary file formats</h1>
    <p class="post-meta"><time datetime="2011-11-09T00:00:00-05:00" itemprop="datePublished">Nov 9, 2011</time> • Gregory Brown</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Even if we rarely give them much thought, binary file formats are everywhere.
Ranging from images to audio files to nearly every other sort of media you can
imagine, binary files are used because they are an efficient way of
storing information in a ready-to-process format.</p>

<p>Despite their usefulness, binary files are cryptic and appear to be 
difficult to understand on the surface. Unlike a
text-based data format, simply looking at a binary file won’t give you any 
hints about what its contents are. To even begin to understand a binary
encoded file, you need to read its format specification. These specifications 
tend to include lots of details about obscure edge cases, and that makes for
challenging reading unless you already have spent a fair amount of time 
working in the realm of bits and bytes. For these reasons, it’s probably better
to learn by example rather than taking a more formal approach.</p>

<p>In this article, I will show you how to encode and decode the bitmap image
format. Bitmap images have a simple structure, and the format is well documented. 
Despite the fact that you’ll probably never need to work with bitmap images 
at all in your day-to-day work, the concepts involved in both reading and 
writing a BMP file are pretty much the same as any other file format you’ll encounter.</p>

<h3 id="the-anatomy-of-a-bitmap">The anatomy of a bitmap</h3>

<p>A bitmap file consists of several sections of metadata followed by a pixel array that represents the color and position of every pixel in the image. 
The example below demonstrates that even if you break the sequence up into its different parts, it would still be a real 
challenge to understand without any documentation handy:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># coding: binary</span>

<span class="n">hex_data</span> <span class="o">=</span> <span class="sx">%w[
  42 4D 
  46 00 00 00 
  00 00 
  00 00 
  36 00 00 00

  28 00 00 00 
  02 00 00 00 
  02 00 00 00 
  01 00 
  18 00 
  00 00 00 00 
  10 00 00 00 
  13 0B 00 00 
  13 0B 00 00
  00 00 00 00 
  00 00 00 00

  00 00 FF
  FF FF FF 
  00 00 
  FF 00 00 
  00 FF 00 
  00 00
]</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">hex_data</span><span class="p">.</span><span class="nf">each_with_object</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="o">|</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="no">Integer</span><span class="p">(</span><span class="s2">"0x</span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="p">}</span>

<span class="no">File</span><span class="p">.</span><span class="nf">binwrite</span><span class="p">(</span><span class="s2">"example1.bmp"</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</code></pre>
</div>

<p>Once you learn what each section represents, you can start
to interpret the data. For example, if you know that this is a
24-bit per pixel image that is two pixels wide, and two pixels high, you might
be able to make sense of the pixel array data shown below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>00 00 FF
FF FF FF 
00 00 
FF 00 00 
00 FF 00 
00 00
</code></pre>
</div>

<p>If you run this example script and open the image file it produces, you’ll see
something similar to what is shown below once you zoom in close enough to see
its pixels:</p>

<p><img src="http://i.imgur.com/XhKW1.png" alt="Pixels" /></p>

<p>By experimenting with changing some of the values in the pixel array by hand, you will fairly quickly discover the overall structure of the array and the way pixels are represented. After figuring this out, you might also be able to look back on the rest of the file and determine what a few of the fields in the headers are without looking at the documentation.</p>

<p>After exploring a bit on your own, you should check out the <a href="http://en.wikipedia.org/wiki/BMP_file_format#Example_1">field-by-field walkthrough of a 2x2 bitmap file</a> that this example was based on. The information in that table is pretty much all you’ll need to know in order to make sense of the bitmap reader and writer implementations I’ve built for this article.</p>

<h3 id="encoding-a-bitmap-image">Encoding a bitmap image</h3>

<p>Now that you’ve seen what a bitmap looks like in its raw form, I can demonstrate
how to build a simple encoder object that allows you to generate bitmap images
in a much more convenient way. In particular, I’m going to show what I did to
get the following code to output the same image that we rendered via a raw
sequence of bytes earlier:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">bmp</span> <span class="o">=</span> <span class="no">BMP</span><span class="o">::</span><span class="no">Writer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># NOTE: Bitmap encodes pixels in BGR format, not RGB!</span>
<span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"ff0000"</span>
<span class="n">bmp</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"00ff00"</span>
<span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"0000ff"</span>
<span class="n">bmp</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"ffffff"</span>

<span class="n">bmp</span><span class="p">.</span><span class="nf">save_as</span><span class="p">(</span><span class="s2">"example_generated.bmp"</span><span class="p">)</span>
</code></pre>
</div>

<p>Like most binary formats, the bitmap format has a tremendous amount of options
that make building a complete implementation a whole lot more complicated than
just building a tool which is suitable for generating a single type of image. I
realized shortly after skimming the format description that you can skip out on
a lot of the boilerplate information if you stick to 24bit-per-pixel images, so
I decided to do exactly that.</p>

<p>Looking at the implementation from the outside-in, you can see the general
structure of the <code class="highlighter-rouge">BMP::Writer</code> class. Pixels are stored in a two-dimensional
array, and all the interesting things happen at the time you write the image out
to file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Writer</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
      <span class="vi">@width</span><span class="p">,</span> <span class="vi">@height</span> <span class="o">=</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span>

      <span class="vi">@pixels</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@height</span><span class="p">)</span> <span class="p">{</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@width</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"000000"</span> <span class="p">}</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
      <span class="vi">@pixels</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">save_as</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">"wb"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
        <span class="n">write_bmp_file_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">write_dib_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">write_pixel_array</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># ... rest of implementation details omitted for now ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>All bitmap files start out with the bitmap file header, which consists of the
following things:</p>

<ul>
  <li>A two character signature to indicate the file is a bitmap file (typically “BM”).</li>
  <li>A 32bit unsigned little-endian integer representing the size of the file itself.</li>
  <li>A pair of 16bit unsigned little-endian integers reserved for application specific uses.</li>
  <li>A 32bit unsigned little-endian integer representing the offset to where the pixel array starts in the file.</li>
</ul>

<p>The following code shows how <code class="highlighter-rouge">BMP::Writer</code> builds up this header and writes it
to file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Writer</span>
    <span class="nc">PIXEL_ARRAY_OFFSET</span> <span class="o">=</span> <span class="mi">54</span>
    <span class="no">BITS_PER_PIXEL</span>     <span class="o">=</span> <span class="mi">24</span>

    <span class="c1"># ... rest of code as before ...</span>

    <span class="k">def</span> <span class="nf">write_bmp_file_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="s2">"BM"</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="no">PIXEL_ARRAY_OFFSET</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"A2Vv2V"</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">file_size</span>
      <span class="no">PIXEL_ARRAY_OFFSET</span> <span class="o">+</span> <span class="n">pixel_array_size</span> 
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">pixel_array_size</span>
      <span class="p">((</span><span class="no">BITS_PER_PIXEL</span><span class="o">*</span><span class="vi">@width</span><span class="p">)</span><span class="o">/</span><span class="mi">32</span><span class="o">.</span><span class="mi">0</span><span class="p">).</span><span class="nf">ceil</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="vi">@height</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Out of the five fields in this header, only the file size ended up being
dynamic. I was able to treat the pixel array offset as a constant because the
headers for 24 bit color images take up a fixed amount of space. The file size
computations<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> will make sense later once we examine the way that the pixel 
array gets encoded.</p>

<p>The tool that makes it possible for us to convert these various field values
into binary sequences is <code class="highlighter-rouge">Array#pack</code>. If you note that the file size of our
reference image is 2x2 bitmap is 70 bytes, it becomes clear what <code class="highlighter-rouge">pack</code>
is actually doing for us when we examine the byte by byte values 
in the following example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"BM"</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">54</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"A2Vv2V"</span><span class="p">)</span> 
<span class="nb">p</span> <span class="n">header</span><span class="p">.</span><span class="nf">bytes</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="s2">"%.2x"</span> <span class="o">%</span> <span class="n">e</span> <span class="p">}</span>

<span class="cm">=begin expected output (NOTE: reformatted below for easier reading)
  ["42", "4d", 
   "46", "00", "00", "00", 
   "00", "00", 
   "00", "00", 
   "36", "00", "00", "00"]
=end</span>
</code></pre>
</div>
<p>The byte sequence for the file header exactly matches that of our reference image, 
which indicates that the proper bitmap file header is being generated. 
Below I’ve listed out how each field in the header encoded:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  "A2" -&gt; arbitrary binary string of width 2 (packs "BM" as: 42 4d)
  "V"  -&gt; a 32bit unsigned little endian int (packs 70 as: 46 00 00 00)
  "v2" -&gt; two 16bit unsigned little endian ints (packs 0, 0 as: 00 00 00 00)
  "V"  -&gt; a 32bit unsigned little endian int (packs 54 as: 36 00 00 00)
</code></pre>
</div>

<p>While I went to the effort of expanding out the byte sequences to make it easier
to see what is going on, you don’t typically need to do this at all while
working with <code class="highlighter-rouge">Array#pack</code> as long as you craft your template strings carefully.
But like anything else in Ruby, it’s nice to be able to write little scripts or
hack around a bit in <code class="highlighter-rouge">irb</code> whenever you’re trying to figure out how your
code is actually working.</p>

<p>After figuring out how to encode the file header, the next step was to work on
the DIB header, which includes some metadata about the image and how it should
be displayed on the screen:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Writer</span>
    <span class="nc">DIB_HEADER_SIZE</span>    <span class="o">=</span> <span class="mi">40</span>
    <span class="no">PIXELS_PER_METER</span>   <span class="o">=</span> <span class="mi">2835</span> <span class="c1"># 2835 pixels per meter is basically 72dpi</span>

    <span class="c1"># ... other code as before ...</span>

   <span class="k">def</span> <span class="nf">write_dib_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="no">DIB_HEADER_SIZE</span><span class="p">,</span> <span class="vi">@width</span><span class="p">,</span> <span class="vi">@height</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="no">BITS_PER_PIXEL</span><span class="p">,</span>
               <span class="mi">0</span><span class="p">,</span> <span class="n">pixel_array_size</span><span class="p">,</span> <span class="no">PIXELS_PER_METER</span><span class="p">,</span> <span class="no">PIXELS_PER_METER</span><span class="p">,</span> 
               <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"Vl&lt;2v2V2l&lt;2V2"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Because we are only working on a very limited subset of BMP features, it’s
possible to construct the DIB header mostly from preset constants combined with
a few values that we already computed for the BMP file header.</p>

<p>The <code class="highlighter-rouge">pack</code> statement in the above code works in a very similar fashion as the
code that writes out the BMP file header, with one exception: it needs to handle
signed 32-bit little endian integers. This data type does not have a pattern of its own, 
but instead is a composite pattern made up of two
characters: <code class="highlighter-rouge">l&lt;</code>. The first character (<code class="highlighter-rouge">l</code>) instructs Ruby to read a 32-bit
signed integer, and the second character (<code class="highlighter-rouge">&lt;</code>) tells it to read it in
little-endian byte order.</p>

<p>It isn’t clear to me at all why a bitmap image could contain negative values for
its width, height, and pixel density – this is just how the format is
specified. Because our goal is to learn about binary file processing and not
image format esoterica, it’s fine to treat that design decision as a black
box for now and move on to looking at how the pixel array is processed.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Writer</span>
    <span class="c1"># .. other code as before ...</span>

    <span class="k">def</span> <span class="nf">write_pixel_array</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="vi">@pixels</span><span class="p">.</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
        <span class="n">row</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">color</span><span class="o">|</span>
          <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">pixel_binstring</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">row_padding</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">pixel_binstring</span><span class="p">(</span><span class="n">rgb_string</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span> <span class="k">unless</span> <span class="n">rgb_string</span> <span class="o">=~</span> <span class="sr">/\A\h{6}\z/</span>
      <span class="p">[</span><span class="n">rgb_string</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"H6"</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">row_padding</span>
      <span class="s2">"</span><span class="se">\x0</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="vi">@width</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The most interesting thing to note about this code is that each row of pixels ends up getting padded with some null characters. This is to ensure that each row of pixels is aligned on WORD boundaries (4 byte sequences). This is a semi-arbitrary limitation that has to do with file storage constraints, but things like this are common in binary files.</p>

<p>The calculations below show how much padding is needed to bring rows of various widths up to a multiple of 4, and explains how I derived the computation for the <code class="highlighter-rouge">row_padding</code> method:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Width 2 : 2 * 3 Bytes per pixel = 6 bytes  + 2 padding  = 8
Width 3 : 3 * 3 Bytes per pixel = 9 bytes  + 3 padding  = 12
Width 4 : 4 * 3 Bytes per pixel = 12 bytes + 0 padding  = 12
Width 5 : 5 * 3 Bytes per pixel = 15 bytes + 1 padding  = 16
Width 6 : 6 * 3 Bytes per pixel = 18 bytes + 2 padding  = 20
Width 7 : 7 * 3 Bytes per pixel = 21 bytes + 3 padding  = 24
...
</code></pre>
</div>

<p>Sometimes calculations like this are provided for you in format specifications,
other times you need to derive them yourself. Choosing to work
with only 24bit per pixel images allowed me to skirt the question of how to
generalize this computation to an arbitrary amount of bits per pixel.</p>

<p>While the padding code is definitely the most interesting aspect of the pixel array, there are a couple other details about this implementation worth discussing. In particular, we should take a closer look at the <code class="highlighter-rouge">pixel_binstring</code> method:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pixel_binstring</span><span class="p">(</span><span class="n">rgb_string</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">ArgumentError</span> <span class="k">unless</span> <span class="n">rgb_string</span> <span class="o">=~</span> <span class="sr">/\A\h{6}\z/</span>
  <span class="p">[</span><span class="n">rgb_string</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"H6"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This is the method that converts the values we set in the pixel array via lines like <code class="highlighter-rouge">bmp[0,0] = "ff0000"</code> into actual binary sequences. It starts by matching the string with a regex to ensure that the input string is a valid sequence of 6 hexadecimal digits. If the validation succeeds, it then packs those values into a binary sequence, creating a string with three bytes in it. The example below should make it clear what is going on here:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt; ["ffa0ff"].pack("H6").bytes.to_a
=&gt; [255, 160, 255]
</code></pre>
</div>

<p>This pattern makes it possible for us to specify color values directly in hexadecimal strings and then convert them to their numeric value just before they get written to the file.</p>

<p>With this last detail explained, you should now understand how to build a
functional bitmap encoder for writing 24bit color images. If seeing things
broken out step by step caused you to lose a sense of the big picture, you can
check out the <a href="https://gist.github.com/1351737">source code for BMP::Writer</a>. Feel free to play around with it a bit before moving on to the next section: the best way to learn is to actually run these code samples and try to extend them and/or break them in various ways.</p>

<h3 id="decoding-a-bitmap-image">Decoding a bitmap image</h3>

<p>As you might expect, there is a nice symmetry between encoding and decoding binary files. To show just to what extent this is the case, I will walk you through the code which makes the following example run:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">bmp</span> <span class="o">=</span> <span class="no">BMP</span><span class="o">::</span><span class="no">Reader</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"example1.bmp"</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">bmp</span><span class="p">.</span><span class="nf">width</span>  <span class="c1">#=&gt; 2</span>
<span class="nb">p</span> <span class="n">bmp</span><span class="p">.</span><span class="nf">height</span> <span class="c1">#=&gt; 2</span>

<span class="nb">p</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#=&gt; "ff0000"   </span>
<span class="nb">p</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#=&gt; "00ff00" </span>
<span class="nb">p</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#=&gt; "0000ff" </span>
<span class="nb">p</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#=&gt; "ffffff" </span>
</code></pre>
</div>

<p>The general structure of <code class="highlighter-rouge">BMP::Reader</code> ended up being quite similar to what I did for <code class="highlighter-rouge">BMP::Writer</code>. The code below shows the methods which define the public interface:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span>
  <span class="k">class</span> <span class="nc">Reader</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">bmp_filename</span><span class="p">)</span> 
      <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">bmp_filename</span><span class="p">,</span> <span class="s2">"rb"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
        <span class="n">read_bmp_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="c1"># does some validations</span>
        <span class="n">read_dib_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="c1"># sets @width, @height</span>
        <span class="n">read_pixels</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>     <span class="c1"># populates the @pixels array</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="kp">attr_reader</span> <span class="ss">:width</span><span class="p">,</span> <span class="ss">:height</span>

    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
      <span class="vi">@pixels</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This time, we still are working with an ordinary array of arrays to store the
pixel data, and most of the work gets done as soon as the file is read in the
constructor. Because I decided to support only a single image type, most of the
work of reading the headers is just for validation purposes. In fact, the
<code class="highlighter-rouge">read_bmp_header</code> method does nothing more than some basic sanity checking, as
shown below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span>
  <span class="k">class</span> <span class="nc">Reader</span>
    <span class="nc">PIXEL_ARRAY_OFFSET</span> <span class="o">=</span> <span class="mi">54</span>

    <span class="c1"># ...other code as before ...</span>

    <span class="k">def</span> <span class="nf">read_bmp_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="n">header</span> <span class="o">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
      <span class="n">magic_number</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="n">reserved1</span><span class="p">,</span>
      <span class="n">reserved2</span><span class="p">,</span> <span class="n">array_location</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s2">"A2Vv2V"</span><span class="p">)</span>
      
      <span class="nb">fail</span> <span class="s2">"Not a bitmap file!"</span> <span class="k">unless</span> <span class="n">magic_number</span> <span class="o">==</span> <span class="s2">"BM"</span>

      <span class="k">unless</span> <span class="n">file</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="n">file_size</span>
        <span class="nb">fail</span> <span class="s2">"Corrupted bitmap: File size is not as expected"</span> 
      <span class="k">end</span>

      <span class="k">unless</span> <span class="n">array_location</span> <span class="o">==</span> <span class="no">PIXEL_ARRAY_OFFSET</span>
        <span class="nb">fail</span> <span class="s2">"Unsupported bitmap: pixel array does not start where expected"</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The key thing to notice about this code is that it reads from the file just the bytes it needs in order to parse the header. This makes it possible to validate a very large file without loading much data into memory. Reading entire files into memory is rarely a good idea, and this is especially true when it comes to binary data because doing so will actually make your job harder rather than easier.</p>

<p>Once the header data is loaded into a string, the <code class="highlighter-rouge">String#unpack</code> method is used to extract some values from it. Notice here how <code class="highlighter-rouge">String#unpack</code> uses the same template syntax as <code class="highlighter-rouge">Array#pack</code> and simply provides the inverse operation. While the <code class="highlighter-rouge">pack</code> operation converts an array of values into a string of binary data, the <code class="highlighter-rouge">unpack</code> operation converts a binary string into an array of processed values. This allows us to recover the information packed into the bitmap file header as Ruby strings and fixnums.</p>

<p>Once these values have been converted into Ruby objects, it’s easy to do some
ordinary comparisons to check to see if they’re what we’d expect them to be.
Because they help detect corrupted files, clearly defined validations are an
important part of writing any decoder for binary file formats. If you do not do
this sort of sanity checking, you will inevitably run into 
subtle processing errors later on that will be much harder to debug.</p>

<p>As you might expect, the implementation of <code class="highlighter-rouge">read_dib_header</code> involves more of
the same sort of extractions and validations. It also sets the <code class="highlighter-rouge">@width</code> and
<code class="highlighter-rouge">@height</code> variables, which we use later to determine how to traverse the encoded
pixel array.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Reader</span>
    <span class="c1"># ... other code as before ...</span>

    <span class="no">BITS_PER_PIXEL</span>     <span class="o">=</span> <span class="mi">24</span>
    <span class="no">DIB_HEADER_SIZE</span>    <span class="o">=</span> <span class="mi">40</span>

    <span class="k">def</span> <span class="nf">read_dib_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="n">header</span> <span class="o">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>

      <span class="n">header_size</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">bits_per_pixel</span><span class="p">,</span> 
      <span class="n">compression_method</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">hres</span><span class="p">,</span> 
      <span class="n">vres</span><span class="p">,</span> <span class="n">n_colors</span><span class="p">,</span> <span class="n">i_colors</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s2">"Vl&lt;2v2V2l&lt;2V2"</span><span class="p">)</span> 

      <span class="k">unless</span> <span class="n">header_size</span> <span class="o">==</span> <span class="no">DIB_HEADER_SIZE</span>
        <span class="nb">fail</span> <span class="s2">"Corrupted bitmap: DIB header does not match expected size"</span>
      <span class="k">end</span>

      <span class="k">unless</span> <span class="n">planes</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="nb">fail</span> <span class="s2">"Corrupted bitmap: Expected 1 plane, got </span><span class="si">#{</span><span class="n">planes</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">end</span>

      <span class="k">unless</span> <span class="n">bits_per_pixel</span> <span class="o">==</span> <span class="no">BITS_PER_PIXEL</span>
        <span class="nb">fail</span> <span class="s2">"</span><span class="si">#{</span><span class="n">bits_per_pixel</span><span class="si">}</span><span class="s2"> bits per pixel bitmaps are not supported"</span>
      <span class="k">end</span>

      <span class="k">unless</span> <span class="n">compression_method</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="nb">fail</span> <span class="s2">"Bitmap compression not supported"</span>
      <span class="k">end</span>

      <span class="k">unless</span> <span class="n">image_size</span> <span class="o">+</span> <span class="no">PIXEL_ARRAY_OFFSET</span> <span class="o">==</span> <span class="n">file</span><span class="p">.</span><span class="nf">size</span>
        <span class="nb">fail</span> <span class="s2">"Corrupted bitmap: pixel array size isn't as expected"</span>
      <span class="k">end</span>

      <span class="vi">@width</span><span class="p">,</span> <span class="vi">@height</span> <span class="o">=</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Beyond what has already been said about this example and the DIB header itself, there isn’t much more to discuss about this particular method. That means we can finally take a look at how <code class="highlighter-rouge">BMP::Reader</code> converts the encoded pixel array into a nested Ruby array structure.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BMP</span> 
  <span class="k">class</span> <span class="nc">Reader</span>
    <span class="k">def</span> <span class="nf">read_pixels</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="vi">@pixels</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@height</span><span class="p">)</span> <span class="p">{</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@width</span><span class="p">)</span> <span class="p">}</span>

      <span class="p">(</span><span class="vi">@height</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="nf">downto</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="o">|</span>
        <span class="mi">0</span><span class="p">.</span><span class="nf">upto</span><span class="p">(</span><span class="vi">@width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
          <span class="vi">@pixels</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">unpack</span><span class="p">(</span><span class="s2">"H6"</span><span class="p">).</span><span class="nf">first</span>
        <span class="k">end</span>
        <span class="n">advance_to_next_row</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">advance_to_next_row</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
      <span class="n">padding_bytes</span> <span class="o">=</span> <span class="vi">@width</span> <span class="o">%</span> <span class="mi">4</span>
      <span class="k">return</span> <span class="k">if</span> <span class="n">padding_bytes</span> <span class="o">==</span> <span class="mi">0</span>

      <span class="n">file</span><span class="p">.</span><span class="nf">pos</span> <span class="o">+=</span> <span class="n">padding_bytes</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>One interesting aspect of this code is that it uses explicit numerical iterators. These are relatively rare in idiomatic Ruby, but I did not see a better way to approach this particular problem. Rows are listed in the pixel array from the bottom up, while the image itself still gets indexed from the top down (with 0 at the top). This makes it necessary to iterate over the row numbers in reverse order, and the use of <code class="highlighter-rouge">downto</code> is the best way I could find to do that.</p>

<p>The other thing worth noticing about this code is that in the <code class="highlighter-rouge">advance_to_next_row</code> method, we actually move the pointer ahead in the file rather than reading the padding bytes between each row. This makes little difference when you’re dealing with a maximum of three bytes of padding per row (two in this case), but is a good practice for writing more efficient code that consumes less memory.</p>

<p>When you take all these code examples and glue them together into a single class
definition, you’ll end up with a <code class="highlighter-rouge">BMP::Reader</code> object that is capable giving you
the width and height of a 24bit BMP image as well as the color of each and every
pixel in the image. For those who’d like to experiment further, the <a href="https://gist.github.com/1352294">source code
for BMP::Reader</a> is available.</p>

<h3 id="reflections">Reflections</h3>

<p>The thing that makes me appreciate binary file formats is that if you just learn
a few basic computing concepts, there are few things that could be more
fundamentally simple to work with. But simple does not necessarily mean easy, and in the process of writing this article I realized that some aspects of binary file processing are not quite as trivial or intuitive as I originally thought they were.</p>

<p>What I can say is that this kind of work gets a whole lot easier with practice.
Due to my work on <a href="http://prawnpdf.org">Prawn</a> I have written
implementations for various different binary formats including PDF, PNG, JPG,
and TTF. These formats each have their differences, but my experience tells me 
that if you fully understand the examples in this article, then you are already 
well on your way to tackling pretty much any binary file format.</p>

<blockquote>
  <p>NOTE: If you’d like to learn more about this topic, consider doing the Practicing Ruby self-guided course on <a href="https://practicingruby.com/articles/study-guide-1?u=dc2ab0f9bb">Streams, Files, and Sockets</a>. You’ve already completed one of its reading exercises by working through this article!</p>
</blockquote>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>To determine the storage space needed for the pixel array in BMP images, I used the computations described in the <a href="http://en.wikipedia.org/wiki/BMP_file_format#Pixel_storage">Wikipedia article on bitmap images</a>. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Send questions and feedback to:</li>
          <li><a href="mailto:gregory@practicingdeveloper.com">gregory@practicingdeveloper.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/practicingdeveloper"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">practicingdeveloper</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/practicingdev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">practicingdev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The world's largest collection of lessons for experienced Ruby developers.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
