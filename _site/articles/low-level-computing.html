<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Exploring low-level computing concepts with Ruby</title>
  <meta name="description" content="  This issue of Practicing Ruby was directly inspired by Nick Morgan’sEasy 6502 tutorial. Whilethe Ruby code in this article is my own, the bytecode for theS...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/articles/low-level-computing">
  <link rel="alternate" type="application/rss+xml" title="Practicing Ruby" href="http://yourdomain.com/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-33127211-2', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Practicing Ruby</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="/about">About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Exploring low-level computing concepts with Ruby</h1>
    <p class="post-meta"><time datetime="2013-10-01T00:00:00-04:00" itemprop="datePublished">Oct 1, 2013</time> • Gregory Brown</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>This issue of Practicing Ruby was directly inspired by Nick Morgan’s
<a href="http://skilldrick.github.io/easy6502/">Easy 6502</a> tutorial. While
the Ruby code in this article is my own, the bytecode for the
Snake6502 game was shamelessly stolen from Nick. Be sure to check
out <a href="http://skilldrick.github.io/easy6502/">Easy 6502</a> if this topic 
interests you; it’s one of the best programming tutorials I’ve ever seen.</p>
</blockquote>

<p>The sea of numbers you see below is about as close to the metal as programming gets:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>0600: 20 06 06 20 38 06 20 0d 06 20 2a 06 60 a9 02 85 
0610: 02 a9 04 85 03 a9 11 85 10 a9 10 85 12 a9 0f 85 
0620: 14 a9 04 85 11 85 13 85 15 60 a5 fe 85 00 a5 fe 
0630: 29 03 18 69 02 85 01 60 20 4d 06 20 8d 06 20 c3 
0640: 06 20 19 07 20 20 07 20 2d 07 4c 38 06 a5 ff c9 
0650: 77 f0 0d c9 64 f0 14 c9 73 f0 1b c9 61 f0 22 60 
0660: a9 04 24 02 d0 26 a9 01 85 02 60 a9 08 24 02 d0 
0670: 1b a9 02 85 02 60 a9 01 24 02 d0 10 a9 04 85 02 
0680: 60 a9 02 24 02 d0 05 a9 08 85 02 60 60 20 94 06 
0690: 20 a8 06 60 a5 00 c5 10 d0 0d a5 01 c5 11 d0 07 
06a0: e6 03 e6 03 20 2a 06 60 a2 02 b5 10 c5 10 d0 06 
06b0: b5 11 c5 11 f0 09 e8 e8 e4 03 f0 06 4c aa 06 4c 
06c0: 35 07 60 a6 03 ca 8a b5 10 95 12 ca 10 f9 a5 02 
06d0: 4a b0 09 4a b0 19 4a b0 1f 4a b0 2f a5 10 38 e9 
06e0: 20 85 10 90 01 60 c6 11 a9 01 c5 11 f0 28 60 e6 
06f0: 10 a9 1f 24 10 f0 1f 60 a5 10 18 69 20 85 10 b0 
0700: 01 60 e6 11 a9 06 c5 11 f0 0c 60 c6 10 a5 10 29 
0710: 1f c9 1f f0 01 60 4c 35 07 a0 00 a5 fe 91 00 60 
0720: a2 00 a9 01 81 10 a6 03 a9 00 81 10 60 a2 00 ea 
0730: ea ca d0 fb 60 
</code></pre>
</div>

<p>Although you probably can’t tell by looking at it, what you see here
is assembled machine code for the venerable 6502 processor that powered 
many of the classic video games of the 1980s. When executed in simulated
environment, this small set of cryptic instructions produces a minimal
version of the Snake arcade game, as shown below:</p>

<p><img src="http://i.imgur.com/0DsKeoy.gif" alt="" /></p>

<p>In this article, we will build a stripped down 6502 simulator 
in JRuby that is complete enough to run this game. If you haven’t done much 
low-level programming before, don’t worry! Most of what follows is 
just ordinary Ruby code. I will also be showing you a ton of examples 
along the way, and those should help keep you on track. You might also
want to grab <a href="https://github.com/sandal/vintage">full source code</a> for 
the simulator, so that you can experiment with it while 
reading through this article.</p>

<h2 id="warmup-exercise-reverse-engineering-snake6502">Warmup exercise: Reverse engineering Snake6502</h2>

<p>An interesting property of machine code is that if you know its structure,
you can convert it back into assembly language. Among other things,
the ability to disassemble machine code is useful for debugging and
exploration purposes. Let’s try this out on Snake6502!</p>

<p>The output below shows memory locations, machine code, and assembly code for the
first 28 instructions of the game. These instructions are responsible for
initializing the state of the snake and the apple before the main event 
loop kicks off. You don’t need to understand exactly how they work right
now, just try to get a feel for how the code in the <code class="highlighter-rouge">hexdump</code> column corresponds
to the code in the <code class="highlighter-rouge">assembly</code> column:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>address  hexdump     assembly
------------------------------
$0600    20 06 06    JSR $0606
$0603    20 38 06    JSR $0638
$0606    20 0d 06    JSR $060d
$0609    20 2a 06    JSR $062a
$060c    60          RTS
$060d    a9 02       LDA #$02
$060f    85 02       STA $02
$0611    a9 04       LDA #$04
$0613    85 03       STA $03
$0615    a9 11       LDA #$11
$0617    85 10       STA $10
$0619    a9 10       LDA #$10
$061b    85 12       STA $12
$061d    a9 0f       LDA #$0f
$061f    85 14       STA $14
$0621    a9 04       LDA #$04
$0623    85 11       STA $11
$0625    85 13       STA $13
$0627    85 15       STA $15
$0629    60          RTS
$062a    a5 fe       LDA $fe
$062c    85 00       STA $00
$062e    a5 fe       LDA $fe
$0630    29 03       AND #$03
$0632    18          CLC
$0633    69 02       ADC #$02
$0635    85 01       STA $01
$0637    60          RTS
</code></pre>
</div>

<p>If you look at the output carefully, you’ll be able to notice some patterns even
if you don’t understand what the instructions themselves are meant to do. For
example, each instruction is made up of between 1-3 bytes of machine code. The
first byte in each instruction tells us what operation it is, and the remaining
bytes (if any) form its operand.</p>

<p>If you take a look at the first four instructions, it is easy to see that the
opcode <code class="highlighter-rouge">20</code> corresponds to the <code class="highlighter-rouge">JSR</code> instruction. Forming its operand is
similarly straightforward, because it’s the same number in both places, 
just with opposite byte order:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>20 06 06 -&gt; JSR $0606  
20 38 06 -&gt; JSR $0638
20 0d 06 -&gt; JSR $060d
20 2a 06 -&gt; JSR $062a
</code></pre>
</div>

<p>If you ignore the symbols in front of the numbers for the moment, mapping single
byte operands is even easier, because they’re represented the same way in both
the machine code and the assembly code. Knowing that the <code class="highlighter-rouge">85</code> opcode maps
to the <code class="highlighter-rouge">STA</code> operation, it should be easy to see how <code class="highlighter-rouge">11, 13, 15</code> map to
<code class="highlighter-rouge">$11, $13, $15</code> in the following example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>85 11  -&gt; STA $11
85 13  -&gt; STA $13
85 15  -&gt; STA $15
</code></pre>
</div>

<p>But the symbols in front of the numbers in assembly language obviously mean
something. If you carefully look at the machine code, you’ll be able to find
that the same operation can have multiple different opcodes, each of which
identify a particular kind of operand:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a9 0f -&gt; LDA #$0f
a5 fe -&gt; LDA $fe
</code></pre>
</div>

<p>Without getting into too much detail here, the example above shows us that both
<code class="highlighter-rouge">a9</code> and <code class="highlighter-rouge">a5</code> correspond to the <code class="highlighter-rouge">LDA</code> instruction. The difference between the
two opcodes is that <code class="highlighter-rouge">a9</code> treats its operand as an immediate value, and <code class="highlighter-rouge">a5</code> 
interprets it as a memory address. In assembly code, this difference is
represented syntactically (<code class="highlighter-rouge">#$xx</code> vs. <code class="highlighter-rouge">$xx</code>), but in the machine code we must
rely on numbers alone.</p>

<p>The various ways of interpreting operands (called “addressing modes”) are
probably the most confusing part of working with 6502 code. There are
about a dozen of them, and to get Snake6502 running, we need to implement
most of them. The good news is that every addressing mode is just a
roundabout way of converting an operand into a particular address in memory, and once you have that
address, the operations themselves do not care about how you computed it.
Once you sweep all that stuff under the rug, you can end up with clean
operation definitions like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># NOTE: 'e' refers to the address that was computed from the instruction's</span>
<span class="c1"># operand and addressing mode.</span>

<span class="no">LDA</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>  <span class="p">}</span> 
<span class="no">STA</span> <span class="p">{</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>  <span class="o">=</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
</div>

<p>This realization also tells us that the memory module will not need to take
addressing modes into account as long as they’re precomputed elsewhere. With
that in mind, let’s get started building a storage model for our simulator.
We’ll deal with the hairy problem of addressing modes later.</p>

<h2 id="memory">Memory</h2>

<p>Except for a few registers that are used to store intermediate
computations, the 6502 processor relies on its memory for pretty much
everything. Program code, data, and the system stack all reside in 
the same 16-bit addressing space. Even flow control is entirely
dependent on memory: the program counter itself is nothing more
than an address that is used to look up the next instruction to run.</p>

<p>This “all in one bucket” approach is a double-edged sword. It makes it harder to
write safe programs, but the tradeoff is that the storage model itself is very
simple. Conceptually, the memory module is nothing more than a mapping 
between 16-bit addresses and 8-bit values:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">describe</span> <span class="s2">"Storage"</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:mem</span><span class="p">)</span> <span class="p">{</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>

  <span class="n">it</span> <span class="s2">"can get and set values"</span> <span class="k">do</span>
    <span class="n">mem</span><span class="p">[</span><span class="mh">0x1337</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xAE</span>

    <span class="n">mem</span><span class="p">[</span><span class="mh">0x1337</span><span class="p">].</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0xAE</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>But because the program counter keeps track of a ‘current location’ 
in memory at any point in time, there is a lot more we can do with 
this simple structure. Let’s walk through the remaining tests 
for <code class="highlighter-rouge">Vintage::Storage</code> to see what else it implements.</p>

<p><strong>Program loading</strong></p>

<p>When a program is loaded into memory, there is nothing special about the 
way it is stored, it’s just like any other data. In a real 6502 processer,
a register is used to store the address of the 
next instruction to be run, and that address is used to read an opcode
from memory. In our simulator, we can let the <code class="highlighter-rouge">Storage</code> class keep track 
of this number for us, incrementing it whenever we call 
the <code class="highlighter-rouge">Storage#next</code> method.</p>

<p>The following test shows how to load a program and then walk its code one byte at a time:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"can load a bytecode sequence into memory and traverse it"</span> <span class="k">do</span>
  <span class="n">bytes</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">]</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span><span class="p">)</span> <span class="c1"># load() does not increment counter</span>

  <span class="n">bytes</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The starting position of the program can be an arbitrary location, but
to maintain compatibility with the simulator from the Easy6502 tutorial, we
initialize the program counter to <code class="highlighter-rouge">0x600</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">let</span><span class="p">(</span><span class="ss">:program_offset</span><span class="p">)</span> <span class="p">{</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="o">::</span><span class="no">PROGRAM_OFFSET</span> <span class="p">}</span>

<span class="n">it</span> <span class="s2">"sets an initial position of $0600"</span> <span class="k">do</span>
  <span class="n">program_offset</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x0600</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p><strong>Flow control + branching</strong></p>

<p>Very rudimentary flow control is supported by setting the 
program counter to a particular address, which causes the 
processor to <code class="highlighter-rouge">jump</code> to the instruction at that address:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"implements jump"</span> <span class="k">do</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">jump</span><span class="p">(</span><span class="n">program_offset</span> <span class="o">+</span> <span class="mh">0xAB</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span> <span class="o">+</span> <span class="mh">0xAB</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Branching can be implemented by only calling <code class="highlighter-rouge">jump</code> when a
condition is met:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"implements conditional branching"</span> <span class="k">do</span>
  <span class="n">big</span>   <span class="o">=</span> <span class="mh">0xAB</span>
  <span class="n">small</span> <span class="o">=</span> <span class="mh">0x01</span>

  <span class="c1"># a false condition does not affect mem.pc</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">small</span> <span class="o">&gt;</span> <span class="n">big</span><span class="p">,</span> <span class="n">program_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span><span class="p">)</span>

  <span class="c1"># true condition jumps to the provided address</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">big</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">,</span> <span class="n">program_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This test case is a bit contrived, so let’s take a look at 
some real Snake6502 code that illustrates how branching meant to be used:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$064d    a5 ff     LDA $ff      # read the last key pressed on the keyboard
$064f    c9 77     CMP #$77     # check if the key was "w" (ASCII code 0x77)
$0651    f0 0d     BEQ $0660    # if so, jump forward to $0660 
$0653    c9 64     CMP #$64     # check if the key was "d" (ASCII code 0x64)
$0655    f0 14     BEQ $066b    # if so, jump forward to $066b
$0657    c9 73     CMP #$73     # check if the key was "s" (ASCII code 0x73)
$0659    f0 1b     BEQ $0676    # if so, jump forward to $0676
$065b    c9 61     CMP #$61     # check if the key was "a" (ASCII code 0x61)
$065d    f0 22     BEQ $0681    # if so, jump forward to $0681
</code></pre>
</div>

<p>Presumably, the code at <code class="highlighter-rouge">$0660</code> starts a procedure that moves the snake’s
head up, the code at <code class="highlighter-rouge">$066b</code> moves it to the right, and so on. In other words,
if one of these <code class="highlighter-rouge">BEQ</code> instructions finds a match, it will jump to the right place 
in the code to handle the relevant condition. But if no match is found, the 
processor will happily continue on to whatever code comes after this set of 
instructions in the program.</p>

<p>The tricky thing about using instructions that rely on <code class="highlighter-rouge">jump</code> (and consequently,
<code class="highlighter-rouge">branch</code>) is that they are essentially GOTO statements. When you see one of
these statements in the code, you know exactly what instruction will be executed
next, but there’s no way of telling if it will ever return to the location
it was called from. To get around this problem, we need support for subroutines
that know how to return to where they’ve been called from. And to implement
<em>those</em>, we need a system stack.</p>

<p><strong>Stack operations</strong></p>

<p>Here are the tests for how we’d like our stack to behave:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">let</span><span class="p">(</span><span class="ss">:stack_origin</span><span class="p">)</span> <span class="p">{</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="o">::</span><span class="no">STACK_ORIGIN</span> <span class="p">}</span>
<span class="n">let</span><span class="p">(</span><span class="ss">:stack_offset</span><span class="p">)</span> <span class="p">{</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="o">::</span><span class="no">STACK_OFFSET</span> <span class="p">}</span>

<span class="n">it</span> <span class="s2">"has a 256 element stack between 0x0100-0x01ff"</span> <span class="k">do</span>
  <span class="n">stack_offset</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x0100</span><span class="p">)</span>
  <span class="n">stack_origin</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0xff</span><span class="p">)</span> <span class="c1"># this value gets added to the offset</span>
<span class="k">end</span>

<span class="n">it</span> <span class="s2">"implements stack-like behavior"</span> <span class="k">do</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">sp</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">stack_origin</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="mh">0x01</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="mh">0x03</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="mh">0x05</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">sp</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">stack_origin</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">pull</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x05</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pull</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x03</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pull</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x01</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">sp</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">stack_origin</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>As the tests indirectly suggest, the stack is a region in memory 
between<code class="highlighter-rouge">$0100</code> and <code class="highlighter-rouge">$01ff</code>, indexed by a stack pointer (<code class="highlighter-rouge">sp</code>).
Each time a value is pushed onto the stack, the value of the 
stack pointer is decremented, and each time a value is pulled, 
the pointer is incremented. This makes it so that the stack
pointer always tells you where the “top of the stack” is.</p>

<p><strong>Subroutines</strong></p>

<p>With a stack in place, we’ll have most of what we need to implement
“Jump to subroutine” (<code class="highlighter-rouge">jsr</code>) and “Return from subroutine” (<code class="highlighter-rouge">rts</code>)
functionality. The behavior of these features will end up 
looking something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"implements jsr/rts"</span> <span class="k">do</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">jsr</span><span class="p">(</span><span class="mh">0x0606</span><span class="p">)</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">jsr</span><span class="p">(</span><span class="mh">0x060d</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x060d</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">rts</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x0606</span><span class="p">)</span>

  <span class="n">mem</span><span class="p">.</span><span class="nf">rts</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">program_offset</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>To make the above test pass, <code class="highlighter-rouge">jsr</code> needs to <code class="highlighter-rouge">push</code> the current 
program counter onto the stack before executing a <code class="highlighter-rouge">jump</code> to the 
specified address. Later when <code class="highlighter-rouge">rts</code> is called, the address is
pulled out of the stack, and then another <code class="highlighter-rouge">jump</code> is executed
to bring you back to where the last <code class="highlighter-rouge">jsr</code> command was executed.
This works fine even in nested subroutine calls, due to the
nature of how stacks work.</p>

<p>The only tricky part is that addresses are 16-bit values, but 
stack entries are limited to single byte values. To get around
this problem, we need a couple helper functions to convert
a 16-bit number into two bytes, and vice-versa:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"can convert two bytes into a 16 bit integer"</span> <span class="k">do</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">int16</span><span class="p">([</span><span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">]).</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">it</span> <span class="s2">"can convert a 16 bit integer into two bytes"</span> <span class="k">do</span>
  <span class="n">mem</span><span class="p">.</span><span class="nf">bytes</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">).</span><span class="nf">must_equal</span><span class="p">([</span><span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">])</span>
<span class="k">end</span>
</code></pre>
</div>

<p>These helpers will also come in handy later, when we need to deal with
addressing modes.</p>

<p><strong>Implementation</strong></p>

<p>Behavior-wise, there is a lot of functionality here. In a high level
environment it would feel a lot like we were mixing distinct concerns,
but at the low level we’re working at it’s understandable that nearly
infinite flexibility is desireable.</p>

<p>Despite the conceptual complexity, the <code class="highlighter-rouge">Storage</code> class is extremely easy to 
implement. In fact, it takes less than 80 lines of code if you don’t
worry about validations and robustness:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">class</span> <span class="nc">Storage</span>
    <span class="nc">PROGRAM_OFFSET</span> <span class="o">=</span> <span class="mh">0x0600</span>
    <span class="no">STACK_OFFSET</span>   <span class="o">=</span> <span class="mh">0x0100</span>
    <span class="no">STACK_ORIGIN</span>   <span class="o">=</span> <span class="mh">0xff</span>

    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@memory</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="vi">@pc</span>     <span class="o">=</span> <span class="no">PROGRAM_OFFSET</span>
      <span class="vi">@sp</span>     <span class="o">=</span> <span class="no">STACK_ORIGIN</span>
    <span class="k">end</span>

    <span class="kp">attr_reader</span> <span class="ss">:pc</span><span class="p">,</span> <span class="ss">:sp</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
      <span class="n">index</span> <span class="o">=</span> <span class="no">PROGRAM_OFFSET</span>

      <span class="n">bytes</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="vi">@memory</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
      <span class="vi">@memory</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="vi">@memory</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">next</span>
      <span class="vi">@memory</span><span class="p">[</span><span class="vi">@pc</span><span class="p">].</span><span class="nf">tap</span> <span class="p">{</span> <span class="vi">@pc</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
      <span class="vi">@pc</span> <span class="o">=</span> <span class="n">address</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">branch</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">unless</span> <span class="nb">test</span>

      <span class="vi">@pc</span> <span class="o">=</span> <span class="n">address</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">jsr</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
      <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">(</span><span class="vi">@pc</span><span class="p">)</span>

      <span class="n">push</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
      <span class="n">push</span><span class="p">(</span><span class="n">high</span><span class="p">)</span>

      <span class="n">jump</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">rts</span>
      <span class="n">h</span> <span class="o">=</span> <span class="n">pull</span>
      <span class="n">l</span> <span class="o">=</span> <span class="n">pull</span>

      <span class="vi">@pc</span> <span class="o">=</span> <span class="n">int16</span><span class="p">([</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="vi">@memory</span><span class="p">[</span><span class="no">STACK_OFFSET</span> <span class="o">+</span> <span class="vi">@sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
      <span class="vi">@sp</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">pull</span>
      <span class="vi">@sp</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="vi">@memory</span><span class="p">[</span><span class="no">STACK_OFFSET</span> <span class="o">+</span> <span class="vi">@sp</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">int16</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
      <span class="n">bytes</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"c*"</span><span class="p">).</span><span class="nf">unpack</span><span class="p">(</span><span class="s2">"v"</span><span class="p">).</span><span class="nf">first</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">bytes</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
      <span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s2">"v"</span><span class="p">).</span><span class="nf">unpack</span><span class="p">(</span><span class="s2">"c*"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For such boring code, its a bit surprising to think that it can be a fundamental
building block for generic computing. Keep in mind of course that we’re building
a simulation and not a real piece of hardware, and we’re doing it in one of the
highest level languages you can use.</p>

<p>If it already feels like we’re cheating, just wait until you see the next trick!</p>

<h2 id="memory-mapped-io">Memory-mapped I/O</h2>

<p>To implement Snake6502, our simulator needs to be able to generate random
numbers, read keyboard input, and also display graphics on the screen. None of
these features are directly supported by the 6502 instruction set, so that means
that every individual system had to come up with its own way of doing things.
This is one of many things that causes machine code (especially old-school
machine code) to not be directly portable from one system to another.</p>

<p>Because we’re trying to get Snake6502 to run in our simulator without modifying
its bytecode, we’re more-or-less constrained to following the approach used by
the Easy6502 simulator: memory-mapped I/O.</p>

<p>This approach is actually very easy to implement in a simulated environment: you
add hooks around certain memory addresses so that when they are accessed, they
execute some custom code rather than directly reading or writing a 
value to memory. In the case of Snake6502, we expect the following behaviors:</p>

<ul>
  <li>Reading from <code class="highlighter-rouge">$fe</code>  returns a random 8-bit integer.</li>
  <li>Reading from <code class="highlighter-rouge">$ff</code> retrieves the ASCII code of the last key 
pressed on the keyboard.</li>
  <li>Writing to addresses between <code class="highlighter-rouge">$0200</code> to <code class="highlighter-rouge">$05ff</code> will render
pixels to the screen. (<code class="highlighter-rouge">$0200</code> is the top-left corner
of the 32x32 display, and <code class="highlighter-rouge">$05ff</code> is the bottom-right corner.)</li>
</ul>

<p>These features could be added directly to the <code class="highlighter-rouge">Storage</code> class,  but it would
feel a bit awkward to clutter up a generic module with some very specific edge
cases. For that reason, it is probably better to implement them as a module
mixin:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">module</span> <span class="nn">MemoryMap</span>
    <span class="no">RANDOMIZER</span>  <span class="o">=</span> <span class="mh">0xfe</span>
    <span class="no">KEY_PRESS</span>   <span class="o">=</span> <span class="mh">0xff</span>
    <span class="no">PIXEL_ARRAY</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x0200</span><span class="p">.</span><span class="nf">.</span><span class="mh">0x05ff</span><span class="p">)</span>

    <span class="kp">attr_accessor</span> <span class="ss">:ui</span>

    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
      <span class="k">case</span> <span class="n">address</span>
      <span class="k">when</span> <span class="no">RANDOMIZER</span>
        <span class="nb">rand</span><span class="p">(</span><span class="mh">0xff</span><span class="p">)</span>
      <span class="k">when</span> <span class="no">KEY_PRESS</span>
        <span class="n">ui</span><span class="p">.</span><span class="nf">last_keypress</span>
      <span class="k">else</span>
        <span class="k">super</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
      <span class="k">super</span>

      <span class="k">if</span> <span class="no">PIXEL_ARRAY</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">ui</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mh">0x0200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>You probably already have a good idea of how <code class="highlighter-rouge">MemoryMap</code> works from seeing
its implementation, but it wouldn’t hurt to see an example of how it is
used before we move on. Here’s how to display a single pixel on the 
screen, randomly varying its color until the spacebar (ASCII code 0x20) 
is pressed:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">mem</span> <span class="o">=</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="p">.</span><span class="nf">new</span>
<span class="n">mem</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">Vintage</span><span class="o">::</span><span class="no">MemoryMap</span><span class="p">)</span>

<span class="n">mem</span><span class="p">.</span><span class="nf">ui</span> <span class="o">=</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Display</span><span class="p">.</span><span class="nf">new</span> 

<span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x0410</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="mh">0xfe</span><span class="p">])</span> <span class="k">until</span> <span class="n">mem</span><span class="p">[</span><span class="mh">0xff</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x20</span> 
</code></pre>
</div>

<p>It’s worth noting that this is the only code in the entire simulator that
directly depends on a connection to some sort of user interface, and the
protocol consists of just two methods: <code class="highlighter-rouge">ui.update(x, y, color)</code> and
<code class="highlighter-rouge">ui.last_keypress</code>. In our case, we use a JRuby-based GUI, but anything
else could be substituted as long as it implemented these two methods.</p>

<p>At this point, our storage model is pretty much complete. We now can 
turn our attention to various number crunching features.</p>

<h2 id="registers-and-flags">Registers and Flags</h2>

<p>In order to get Snake6502 to run, we need all six of
the programmable registers that the processor provides. We’ve handled two of
them already (the stack pointer and the program counter), so we just have four
more to implement: A, X, Y, and P. A few design constraints will help make this
work go a whole lot faster:</p>

<ul>
  <li>
    <p>Most of the operations that can be done on A are done the same way on X and Y,
so we can implement some generic functions that operate on all three of them.</p>
  </li>
  <li>
    <p>We can implement the status register (P) as a collection of individual
attributes, rather than seven 1-bit flags packs into a single byte.</p>
  </li>
  <li>
    <p>Because Snake6502 only relies on the (c)arry, (n)egative, and (z)ero flags
from the status register, we can skip implementing the other four status flags 
and still have a playable game.</p>
  </li>
</ul>

<p>With those limitations in mind, let’s work through some specs to understand
how this model ought to behave. For starters, we’ll be building a <code class="highlighter-rouge">Vintage::CPU</code> 
that implements three registers and three flags, initializing them all to 
zero by default:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">describe</span> <span class="s2">"CPU"</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:cpu</span><span class="p">)</span> <span class="p">{</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">CPU</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:registers</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:flags</span><span class="p">)</span>     <span class="p">{</span> <span class="p">[</span><span class="ss">:c</span><span class="p">,</span> <span class="ss">:n</span><span class="p">,</span> <span class="ss">:z</span><span class="p">]</span> <span class="p">}</span>
  
  <span class="n">it</span> <span class="s2">"initializes registers and flags to zero"</span> <span class="k">do</span>
    <span class="p">(</span><span class="n">registers</span> <span class="o">+</span> <span class="n">flags</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="nf">must_equal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

   <span class="c1">#...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>It will be possible to directly set registers via the <code class="highlighter-rouge">#[]=</code> method, because
the behavior will be the same for all three registers:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"allows directly setting registers"</span> <span class="k">do</span>
  <span class="n">registers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
    <span class="n">value</span>  <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mh">0xff</span><span class="p">)</span>

    <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="nf">must_equal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>However, because flags don’t have the same update semantics as registers, we 
will not allow directly setting them via <code class="highlighter-rouge">#[]=</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"does not allow directly setting flags"</span> <span class="k">do</span>
  <span class="n">flags</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
    <span class="n">value</span>  <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mh">0xff</span><span class="p">)</span>

    <span class="n">err</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="p">}.</span><span class="nf">must_raise</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span>
    <span class="n">err</span><span class="p">.</span><span class="nf">message</span><span class="p">.</span><span class="nf">must_equal</span> <span class="s2">"</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> is not a register"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The carry flag (c) can toggled via the <code class="highlighter-rouge">set_carry</code> and <code class="highlighter-rouge">clear_carry</code> 
methods. We’ll need this later for getting the <code class="highlighter-rouge">CPU</code>  into
a clean state whenever we do addition and subtraction 
operations:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"allows setting the c flag via set_carry and clear_carry"</span> <span class="k">do</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">set_carry</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">clear_carry</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Some other instructions will require us to set the carry flag
based on arbitrary conditions, so we’ll need support for that as well:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"allows conditionally setting the c flag via carry_if"</span> <span class="k">do</span>
  <span class="c1"># true condition</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="c1"># false condition</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The N and Z flags are set based on whatever result the <code class="highlighter-rouge">CPU</code> last processed:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"sets z=1 when a result is zero, sets z=0 otherwise"</span> <span class="k">do</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:z</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="mh">0xcc</span><span class="p">)</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:z</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">it</span> <span class="s2">"sets n=1 when result is 0x80 or higher, n=0 otherwise"</span> <span class="k">do</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="mh">0x80</span><span class="p">.</span><span class="nf">.</span><span class="mh">0xff</span><span class="p">))</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:n</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="mh">0x00</span><span class="p">.</span><span class="nf">.</span><span class="mh">0x7f</span><span class="p">))</span>
  <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:n</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">result</code> method also returns a number truncated to fit in a single byte,
because pretty much every place we could store a number in this system
expects 8-bit integers:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="s2">"truncates results to fit in a single byte"</span> <span class="k">do</span>
  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">).</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0x37</span><span class="p">)</span>
<span class="k">end</span>  
</code></pre>
</div>

<p>To help keep the <code class="highlighter-rouge">CPU</code> in a consistent state and to simplify the work
involved in many of the 6502 instructions, we automatically call <code class="highlighter-rouge">cpu.result</code>
whenever a register is set via <code class="highlighter-rouge">CPU#[]=</code>. The tests below show the 
the effects of that behavior:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="n">it</span> <span class="s2">"implicitly calls result() when registers are set"</span> <span class="k">do</span>
    <span class="n">registers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
      <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x100</span>
      
      <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="nf">must_equal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:z</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:n</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span>

      <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
      
      <span class="n">cpu</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="nf">must_equal</span><span class="p">(</span><span class="mh">0xff</span><span class="p">)</span>
      <span class="n">expect_flags</span><span class="p">(</span><span class="ss">:z</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:n</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre>
</div>

<p>Here’s an implementation that satisfies all of the tests we’ve seen so far:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">class</span> <span class="nc">CPU</span>
    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@registers</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:x</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:y</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span>
      <span class="vi">@flags</span>     <span class="o">=</span> <span class="p">{</span> <span class="ss">:z</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:n</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
      <span class="vi">@registers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">||</span> <span class="vi">@flags</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="k">unless</span> <span class="vi">@registers</span><span class="p">.</span><span class="nf">key?</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">key</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> is not a register"</span> 
      <span class="k">end</span>

      <span class="vi">@registers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">set_carry</span>
      <span class="vi">@flags</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">clear_carry</span>
      <span class="vi">@flags</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">carry_if</span><span class="p">(</span><span class="nb">test</span><span class="p">)</span>
      <span class="nb">test</span> <span class="p">?</span> <span class="n">set_carry</span> <span class="p">:</span> <span class="n">clear_carry</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">number</span> <span class="o">&amp;=</span> <span class="mh">0xff</span>

      <span class="vi">@flags</span><span class="p">[</span><span class="ss">:z</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
      <span class="vi">@flags</span><span class="p">[</span><span class="ss">:n</span><span class="p">]</span> <span class="o">=</span> <span class="n">number</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>

      <span class="n">number</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Putting it all together, the role of the <code class="highlighter-rouge">CPU</code> class is mostly just to do some
basic numerical housekeeping that will make implementing 6502 instructions
easier. Consider for example, the <code class="highlighter-rouge">CMP</code> and <code class="highlighter-rouge">BEQ</code> operations, which can
be used together to form a primitive sort of <code class="highlighter-rouge">if</code> statement. We saw these two
operations used together in the earlier example of keyboard input handling:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$064f    c9 77     CMP #$77     # check if the key was "w" (ASCII code 0x77)
$0651    f0 0d     BEQ $0660    # if so, jump forward to $0660 
</code></pre>
</div>

<p>Using a combination of the <code class="highlighter-rouge">CPU</code> and <code class="highlighter-rouge">Storage</code> objects we’ve already built, we’d
be able to define the <code class="highlighter-rouge">CMP</code> and <code class="highlighter-rouge">BEQ</code> operations as shown below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="no">CMP</span> <span class="k">do</span> 
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">-</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">)</span>
<span class="k">end</span>

<span class="no">BEQ</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:z</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Even if we ignore the <code class="highlighter-rouge">cpu.carry_if</code> call, we know from what we’ve seen
already that if <code class="highlighter-rouge">CPU#result</code> is called with a zero value, it will set the Z flag
to 1. We also know that when <code class="highlighter-rouge">Storage#branch</code> is called with a true value, it
will jump to the specified address, otherwise it will do nothing at all. Putting
those two facts together with the Snake6502 shown above tells us that if the
value in the A register is <code class="highlighter-rouge">0x77</code>, execution will jump to <code class="highlighter-rouge">$0600</code>.</p>

<p>At this point, we’re starting to see how 6502 instructions can be
mapped onto the objects we’ve already built, and that means we’re 
close to the finish line.  Before we get there, we only have two obstacles
to clear: implementing addressing modes to handle operands, and building
a program runner that knows how to map raw 6502 code to the operation 
definitions shown above.</p>

<h2 id="addressing-modes">Addressing Modes</h2>

<blockquote>
  <p><strong>NOTE:</strong> The explanation that follows barely scrapes the surface of
this topic. If you want to really understand 6502 addressing modes, you should check
out the <a href="http://skilldrick.github.io/easy6502/#addressing">relevant section</a>
in the Easy6502 tutorial.</p>
</blockquote>

<p>In the very first exercise where we disassembled the first few instructions
of Snake6502, we discovered the presence of several addressing modes
that cause operands to be interpreted in various different ways. To get
the game running, we will need to handle a total of eight different 
addressing modes.</p>

<p>This is a lot of different ways to generate an address, and its intimidating 
to realize we’re only implementing an incomplete subset of what the 6502 processor 
provides. However, its important to keep in mind that the only data structure 
we have to work with is a simple mapping from 16-bit integers to 8-bit 
integers. Among other things, clever indexing can give us the functionality we’d
expect from variables, references, and arrays – all the stuff that doesn’t have
a direct representation in machine code.</p>

<p>I’m going to show the definitions for all of the addressing modes used by
Snake6502 below, which probably won’t make much sense at first glance. But try
to see if you can figure out what some of this code doing:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">module</span> <span class="nn">Operand</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">read</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="k">case</span> <span class="n">mode</span>
      <span class="k">when</span> <span class="s2">"#"</span> <span class="c1"># Implicit </span>
        <span class="kp">nil</span>
      <span class="k">when</span> <span class="s2">"@"</span> <span class="c1"># Relative</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span>

        <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="mh">0x80</span> <span class="p">?</span> <span class="n">offset</span> <span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> 
      <span class="k">when</span> <span class="s2">"IM"</span> <span class="c1"># Immediate</span>
        <span class="n">mem</span><span class="p">.</span><span class="nf">pc</span><span class="p">.</span><span class="nf">tap</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span> <span class="p">}</span>
      <span class="k">when</span> <span class="s2">"ZP"</span> <span class="c1"># Zero Page</span>
        <span class="n">mem</span><span class="p">.</span><span class="nf">next</span>
      <span class="k">when</span> <span class="s2">"ZX"</span> <span class="c1"># Zero Page, X</span>
        <span class="n">mem</span><span class="p">.</span><span class="nf">next</span> <span class="o">+</span> <span class="n">x</span>
      <span class="k">when</span>  <span class="s2">"AB"</span> <span class="c1"># Absolute</span>
        <span class="n">mem</span><span class="p">.</span><span class="nf">int16</span><span class="p">([</span><span class="n">mem</span><span class="p">.</span><span class="nf">next</span><span class="p">,</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span><span class="p">])</span>
      <span class="k">when</span> <span class="s2">"IX"</span> <span class="c1"># Indexed Indirect</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span>

        <span class="n">mem</span><span class="p">.</span><span class="nf">int16</span><span class="p">([</span><span class="n">mem</span><span class="p">[</span><span class="n">e</span> <span class="o">+</span> <span class="n">x</span><span class="p">],</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
      <span class="k">when</span> <span class="s2">"IY"</span> <span class="c1"># Indirect Indexed</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span>

        <span class="n">mem</span><span class="p">.</span><span class="nf">int16</span><span class="p">([</span><span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">else</span>
        <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="n">mode</span><span class="p">.</span><span class="nf">inspect</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now let’s walk through them one-by-one. You can refer to the source code above as needed
to make sense of the following examples.</p>

<p>1) The implicit addressing mode is meant for instructions that either don’t operate 
on a memory address at all, or can infer the address internally. An example
we’ve already seen is the <code class="highlighter-rouge">RTS</code> operations that is used to return from a subroutine –
it gets its data from the stack rather than from an operand, making it a single
byte instruction.</p>

<p>2) The relative addressing mode is used by branches only. Consider
the following example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$0651    f0 0d     BEQ $0660    # if Z=1, jump to $0660 
</code></pre>
</div>

<p>By the time the <code class="highlighter-rouge">$0d</code> operand is read, the program counter will be set to
<code class="highlighter-rouge">$0653</code>. If you add these two numbers together, you get the address to jump to
if Z=1: <code class="highlighter-rouge">$0660</code>.</p>

<p>3) Immediate addressing is used when you want to have an instruction work on the
operand itself. To do so, we return the operand’s address, then increment the 
program counter as normal. In the example below, the computed address (<code class="highlighter-rouge">e</code>) 
is <code class="highlighter-rouge">0x0650</code>, and <code class="highlighter-rouge">mem[e] == 0x77</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$064f    c9 77     CMP #$77
</code></pre>
</div>

<p>4) Zero page addressing is straightforward, it is simply refers to any address
between <code class="highlighter-rouge">$00</code> and <code class="highlighter-rouge">$ff</code>. These are convenient for storing program data in, and
are faster to access because they do not require combining two bytes into a 16
bit integer. We’ve already seen copious use of this address mode throughout
the examples in this article, particularly when working with keyboard input
(<code class="highlighter-rouge">$ff</code>) and random number generation (<code class="highlighter-rouge">$fe</code>).</p>

<p>5) Zero page, X indexing is used for iterating over some simple sequences in
memory. For example, Snake6502 stores the position of each part of the snakes
body in byte pairs starting at memory location <code class="highlighter-rouge">$10</code>. Using this addressing
mode, it is possible to walk over the array by simply incrementing the X
register as you go.</p>

<p>6) We’ve also seen plenty of examples of absolute addressing, especially when
looking at <code class="highlighter-rouge">JSR</code> operations. The only complication involved in processing
these addresses is that two bytes need to be read and then assembled into
a 16bit integer. But since we’ve had to do that in several places already,
it should be easy enough to understand.</p>

<p>7) Indexed indirect addressing gives us a way to dynamically compute an address
from other addresses that we’ve stored in memory. That sounds really confusing,
but the following example should help clear it up. The code below is responsible
for moving the snake by painting a white pixel at its updated head position, and
painting a black pixel at its old tail position:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$0720    a2 00       LDX #$00
$0722    a9 01       LDA #$01
$0724    81 10       STA ($10,X) 
$0726    a6 03       LDX $03
$0728    a9 00       LDA #$00
$072a    81 10       STA ($10,X) 
</code></pre>
</div>

<p>The first three lines are hardcoded to look at memory locations <code class="highlighter-rouge">$10</code> and <code class="highlighter-rouge">$11</code> 
to form an address in the pixel array that refers to the new head of the 
snake. The next three lines do something similar for the tail of the snake,
but with a twist: because the length of the snake is dynamic, it needs to
be looked up from memory. This value is stored in memory location <code class="highlighter-rouge">$03</code>.
So to unpack the whole thing, <code class="highlighter-rouge">STA ($10, X)</code> will take the address <code class="highlighter-rouge">$10</code>, add to
it the number of bytes in the whole snake array, and then look up the address
stored in the last position of that array. That address points to the snake’s
tail in the pixel array, which ends up getting set to black by this instruction.</p>

<p>8) Indirect indexed addressing gives us yet another way to walk over multibyte
structures. In nake6502, this addressing mode is only used for drawing the
apple on the screen. Its position is stored in a 16-bit value stored 
in <code class="highlighter-rouge">$00</code> and <code class="highlighter-rouge">$01</code>, and the following code is used to set its color to a 
random value:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$0719    a0 00       LDY #$00
$071b    a5 fe       LDA $fe
$071d    91 00       STA ($00),Y
</code></pre>
</div>

<p>There are bound to be more interesting uses of these addressing modes, but we
we’ve certainly covered enough ground for now! Don’t worry if you didn’t
understand this section that well, it took me many times reading the Easy6502
tutorial and the source code for Snake6502 before I figured these out myself.</p>

<h2 id="simulator-finally">6502 Simulator (finally!)</h2>

<p>We are now finally at the point where all the hard stuff is done, and all that
remains is to wire up the simulator itself. In other words, it’s time for
the fun part of the project.</p>

<p>The input for the simulator will be a binary file containing the
assembled program code for Snake6502. The bytes in that file not meant to
be read as printable characters, but they can be inspected using a hex editor:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ hexdump examples/snake.rom
0000000 20 06 06 20 38 06 20 0d 06 20 2a 06 60 a9 02 85
0000010 02 a9 04 85 03 a9 11 85 10 a9 10 85 12 a9 0f 85
0000020 14 a9 04 85 11 85 13 85 15 60 a5 fe 85 00 a5 fe
0000030 29 03 18 69 02 85 01 60 20 4d 06 20 8d 06 20 c3
0000040 06 20 19 07 20 20 07 20 2d 07 4c 38 06 a5 ff c9
0000050 77 f0 0d c9 64 f0 14 c9 73 f0 1b c9 61 f0 22 60
0000060 a9 04 24 02 d0 26 a9 01 85 02 60 a9 08 24 02 d0
0000070 1b a9 02 85 02 60 a9 01 24 02 d0 10 a9 04 85 02
0000080 60 a9 02 24 02 d0 05 a9 08 85 02 60 60 20 94 06
0000090 20 a8 06 60 a5 00 c5 10 d0 0d a5 01 c5 11 d0 07
00000a0 e6 03 e6 03 20 2a 06 60 a2 02 b5 10 c5 10 d0 06
00000b0 b5 11 c5 11 f0 09 e8 e8 e4 03 f0 06 4c aa 06 4c
00000c0 35 07 60 a6 03 ca 8a b5 10 95 12 ca 10 f9 a5 02
00000d0 4a b0 09 4a b0 19 4a b0 1f 4a b0 2f a5 10 38 e9
00000e0 20 85 10 90 01 60 c6 11 a9 01 c5 11 f0 28 60 e6
00000f0 10 a9 1f 24 10 f0 1f 60 a5 10 18 69 20 85 10 b0
0000100 01 60 e6 11 a9 06 c5 11 f0 0c 60 c6 10 a5 10 29
0000110 1f c9 1f f0 01 60 4c 35 07 a0 00 a5 fe 91 00 60
0000120 a2 00 a9 01 81 10 a6 03 a9 00 81 10 60 a2 00 ea
0000130 ea ca d0 fb 60
0000135
</code></pre>
</div>

<p>The challenge that is left to be completed is to process
the opcodes and operands in this file and turn them into
a running program. To do that, we will make use of a CSV file 
that lists the operation name and addressing mode for each opcode 
found in file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>00,BRK,#
10,BPL,@
18,CLC,#
20,JSR,AB
# ... rest of instructions go here ...
E6,INC,ZP
E8,INX,#
E9,SBC,IM
F0,BEQ,@
</code></pre>
</div>

<p>Once we know the addressing mode for a given operation, we can read its
operand and turn it into an address (denoted by <code class="highlighter-rouge">e</code>). And once we have <em>that</em>, 
we can execute the commands that are defined in following DSL:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># NOTE: This file contains definitions for every instruction used </span>
<span class="c1"># by Snake6502. Most of the functionality here is a direct result</span>
<span class="c1"># of simple calls to Vintage::Storage and Vintage::CPU instances.</span>

<span class="no">NOP</span> <span class="p">{</span> <span class="p">}</span>
<span class="no">BRK</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">StopIteration</span> <span class="p">}</span>


<span class="no">LDA</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">}</span>
<span class="no">LDX</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">}</span>
<span class="no">LDY</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:y</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">}</span>

<span class="no">TXA</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="p">}</span>

<span class="no">STA</span> <span class="p">{</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">## Counters</span>

<span class="no">INX</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="no">DEX</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>

<span class="no">DEC</span> <span class="p">{</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
<span class="no">INC</span> <span class="p">{</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> 

<span class="c1">## Flow control</span>

<span class="no">JMP</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">jump</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">}</span>

<span class="no">JSR</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">jsr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">}</span>
<span class="no">RTS</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">rts</span> <span class="p">}</span>

<span class="no">BNE</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:z</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>
<span class="no">BEQ</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:z</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>
<span class="no">BPL</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>
<span class="no">BCS</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>
<span class="no">BCC</span> <span class="p">{</span> <span class="n">mem</span><span class="p">.</span><span class="nf">branch</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">## Comparisons</span>

<span class="no">CPX</span> <span class="k">do</span> 
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">-</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> 
<span class="k">end</span>

<span class="no">CMP</span> <span class="k">do</span> 
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">-</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> 
<span class="k">end</span>


<span class="c1">## Bitwise operations</span>

<span class="no">AND</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">}</span>
<span class="no">BIT</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">.</span><span class="nf">result</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="p">}</span>

<span class="no">LSR</span> <span class="k">do</span>
  <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span>
 
  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="k">end</span>

<span class="c1">## Arithmetic</span>

<span class="no">SEC</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">.</span><span class="nf">set_carry</span>   <span class="p">}</span>
<span class="no">CLC</span> <span class="p">{</span> <span class="n">cpu</span><span class="p">.</span><span class="nf">clear_carry</span> <span class="p">}</span>

<span class="no">ADC</span> <span class="k">do</span> 
  <span class="n">t</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">+</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span>
  <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="k">end</span>

<span class="no">SBC</span> <span class="k">do</span>
  <span class="n">t</span>  <span class="o">=</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">-</span> <span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">cpu</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

  <span class="n">cpu</span><span class="p">.</span><span class="nf">carry_if</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">cpu</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We can treat both the opcode lookup CSV and the instructions definitions DSL 
as configuration files, to be loaded into the configuration object 
shown below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"csv"</span>

<span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">class</span> <span class="nc">Config</span>
    <span class="nc">CONFIG_DIR</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../../config"</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">load_codes</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">load_definitions</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="kp">attr_reader</span> <span class="ss">:definitions</span><span class="p">,</span> <span class="ss">:codes</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">load_codes</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">csv_data</span> <span class="o">=</span> <span class="no">CSV</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="no">CONFIG_DIR</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">.csv"</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span> <span class="p">}</span>

      <span class="vi">@codes</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">[</span><span class="n">csv_data</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">load_definitions</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="vi">@definitions</span> <span class="o">=</span> <span class="p">{}</span>

      <span class="nb">instance_eval</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="no">CONFIG_DIR</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">.rb"</span><span class="p">))</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">super</span> <span class="k">unless</span> <span class="nb">id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">.</span><span class="nf">upcase</span>

      <span class="vi">@definitions</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Then finally, we can tie everything together with a <code class="highlighter-rouge">Simulator</code> object that
instantiates all the objects we need, and kicks off a program execution loop:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Vintage</span>
  <span class="k">class</span> <span class="nc">Simulator</span>
    <span class="nc">EvaluationContext</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:mem</span><span class="p">,</span> <span class="ss">:cpu</span><span class="p">,</span> <span class="ss">:e</span><span class="p">)</span>
      
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ui</span><span class="p">)</span>
      <span class="n">config</span> <span class="o">=</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Config</span><span class="p">.</span><span class="nf">new</span>
      <span class="n">cpu</span>    <span class="o">=</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">CPU</span><span class="p">.</span><span class="nf">new</span>
      <span class="n">mem</span>    <span class="o">=</span> <span class="no">Vintage</span><span class="o">::</span><span class="no">Storage</span><span class="p">.</span><span class="nf">new</span>

      <span class="n">mem</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">MemoryMap</span><span class="p">)</span>
      <span class="n">mem</span><span class="p">.</span><span class="nf">ui</span> <span class="o">=</span> <span class="n">ui</span>
      
      <span class="n">mem</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">binread</span><span class="p">(</span><span class="n">file</span><span class="p">).</span><span class="nf">bytes</span><span class="p">)</span>

      <span class="kp">loop</span> <span class="k">do</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">mem</span><span class="p">.</span><span class="nf">next</span>

        <span class="n">op</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="nf">codes</span><span class="p">[</span><span class="n">code</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">name</span>
          <span class="n">e</span> <span class="o">=</span> <span class="no">Operand</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:x</span><span class="p">],</span> <span class="n">cpu</span><span class="p">[</span><span class="ss">:y</span><span class="p">])</span>

          <span class="no">EvaluationContext</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                           <span class="p">.</span><span class="nf">instance_exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="nf">definitions</span><span class="p">[</span><span class="n">op</span><span class="p">])</span>
        <span class="k">else</span>
          <span class="k">raise</span> <span class="no">LoadError</span><span class="p">,</span> <span class="s2">"No operation matches code: </span><span class="si">#{</span><span class="s1">'%.2x'</span> <span class="o">%</span> <span class="n">code</span><span class="si">}</span><span class="s2">"</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>At this point, you’re ready to play Snake! Or if you’ve been following closely
along with this article all the way to the end, you’re probably more likely to
have a cup of coffee or take a nap from information overload. Either way,
congratulations for making it all the way through this long and winding
issue of Practicing Ruby!</p>

<h2 id="further-reading">Further Reading</h2>

<p>This article and the <a href="http://github.com/sandal/vintage">Vintage simulator</a> is built on top of a ton of other
people’s ideas and learning resources. Here are some of the works I referred to
while researching this topic:</p>

<ul>
  <li><a href="http://skilldrick.github.io/easy6502/">Easy 6502</a> by Nick Morgan</li>
  <li><a href="http://en.wikipedia.org/wiki/MOS_Technology_6502">Mos Technology 6502</a> @ Wikipedia</li>
  <li><a href="http://homepage.ntlworld.com/cyborgsystems/CS_Main/6502/6502.htm">Rockwell 6502 Programmer’s Manual</a>  by Bluechip</li>
  <li><a href="http://www.6502.org/tutorials/6502opcodes.html">NMos 6502 opcodes</a> by John Pickens</li>
  <li><a href="https://github.com/joelanders/r6502">r6502</a> by Joe Landers</li>
</ul>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Send questions and feedback to:</li>
          <li><a href="mailto:gregory@practicingdeveloper.com">gregory@practicingdeveloper.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/practicingdeveloper"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">practicingdeveloper</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/practicingdev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">practicingdev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The world's largest collection of lessons for experienced Ruby developers.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
